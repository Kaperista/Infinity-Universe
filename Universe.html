<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>üåå Infinity Universe</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Orbitron', sans-serif;
            overflow: hidden;
            background: #000;
            color: #fff;
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100vh;
            background: radial-gradient(ellipse at center, #0a0e27 0%, #000000 100%);
        }

        .ui-panel {
            position: absolute;
            background: rgba(5, 10, 30, 0.3);
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid rgba(100, 200, 255, 0.1);
            border-radius: 20px;
            padding: 20px;
            color: #e0f0ff;
            font-size: 13px;
            box-shadow: 0 8px 32px rgba(0, 100, 255, 0.1),
                        inset 0 1px 0 rgba(255, 255, 255, 0.1);
            animation: fadeIn 1s ease-out;
            transition: all 0.3s ease;
        }

        .ui-panel:hover {
            background: rgba(10, 20, 50, 0.4);
            border-color: rgba(100, 200, 255, 0.3);
            box-shadow: 0 8px 32px rgba(0, 150, 255, 0.2),
                        inset 0 1px 0 rgba(255, 255, 255, 0.15);
        }

        @keyframes fadeIn {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }

        @keyframes glow {
            0%, 100% { box-shadow: 0 0 5px rgba(100, 200, 255, 0.3); }
            50% { box-shadow: 0 0 20px rgba(100, 200, 255, 0.6); }
        }

        #controls {
            top: 20px;
            left: 20px;
            width: 320px;
            max-height: 85vh;
            overflow-y: auto;
            overflow-x: hidden;
        }

        #info {
            top: 20px;
            right: 20px;
            width: 340px;
            max-height: 85vh;
            overflow-y: auto;
        }

        #spectrum {
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            width: 650px;
            height: 140px;
            padding: 15px;
            background: rgba(5, 10, 30, 0.25);
        }

        #minimap {
            bottom: 20px;
            right: 20px;
            width: 220px;
            height: 220px;
        }

        h3 {
            margin: 0 0 15px 0;
            color: #6cf;
            font-size: 18px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 2px;
            border-bottom: 2px solid rgba(100, 200, 255, 0.2);
            padding-bottom: 8px;
            text-shadow: 0 0 10px rgba(100, 200, 255, 0.5);
        }

        button {
            background: linear-gradient(135deg, rgba(100, 150, 255, 0.3) 0%, rgba(150, 100, 255, 0.3) 100%);
            border: 1px solid rgba(100, 200, 255, 0.4);
            color: white;
            padding: 10px 18px;
            border-radius: 12px;
            cursor: pointer;
            margin: 5px 5px 5px 0;
            font-size: 12px;
            font-family: 'Orbitron', sans-serif;
            transition: all 0.3s ease;
            backdrop-filter: blur(10px);
            position: relative;
            overflow: hidden;
        }

        button:before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.2);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        button:hover:before {
            width: 300px;
            height: 300px;
        }

        button:hover {
            transform: translateY(-2px);
            border-color: rgba(100, 200, 255, 0.8);
            box-shadow: 0 5px 15px rgba(100, 150, 255, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        input[type="range"] {
            width: 100%;
            margin: 10px 0;
            -webkit-appearance: none;
            background: transparent;
        }

        input[type="range"]::-webkit-slider-track {
            width: 100%;
            height: 4px;
            background: linear-gradient(90deg, rgba(100, 150, 255, 0.3), rgba(150, 100, 255, 0.3));
            border-radius: 2px;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 16px;
            width: 16px;
            border-radius: 50%;
            background: linear-gradient(135deg, #6cf, #96f);
            cursor: pointer;
            box-shadow: 0 0 10px rgba(100, 200, 255, 0.8);
            transition: all 0.2s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 20px rgba(100, 200, 255, 1);
        }

        select, input[type="file"] {
            width: 100%;
            padding: 10px;
            margin: 8px 0;
            background: rgba(20, 30, 60, 0.4);
            border: 1px solid rgba(100, 200, 255, 0.3);
            border-radius: 10px;
            color: #e0f0ff;
            font-family: 'Orbitron', sans-serif;
            font-size: 12px;
            transition: all 0.3s;
        }

        select:hover, select:focus {
            background: rgba(30, 40, 80, 0.5);
            border-color: rgba(100, 200, 255, 0.5);
            outline: none;
        }

        .stat-line {
            display: flex;
            justify-content: space-between;
            margin: 8px 0;
            padding: 8px 12px;
            background: rgba(20, 40, 80, 0.2);
            border-radius: 8px;
            border-left: 3px solid rgba(100, 200, 255, 0.4);
            transition: all 0.3s;
        }

        .stat-line:hover {
            background: rgba(30, 50, 100, 0.3);
            border-left-color: rgba(100, 200, 255, 0.8);
            transform: translateX(5px);
        }

        .stat-label {
            color: #6cf;
            text-shadow: 0 0 5px rgba(100, 200, 255, 0.3);
        }

        canvas {
            cursor: crosshair;
        }

        #spectrumCanvas {
            width: 100%;
            height: 110px;
            border-radius: 10px;
        }

        #minimapCanvas {
            width: 100%;
            height: 100%;
            border-radius: 15px;
        }

        .control-group {
            margin: 18px 0;
            padding: 15px;
            background: rgba(10, 20, 50, 0.2);
            border-radius: 12px;
            border: 1px solid rgba(100, 200, 255, 0.1);
            transition: all 0.3s;
        }

        .control-group:hover {
            background: rgba(15, 25, 60, 0.3);
            border-color: rgba(100, 200, 255, 0.2);
        }

        .control-group strong {
            color: #8df;
            font-size: 13px;
            text-shadow: 0 0 8px rgba(100, 200, 255, 0.4);
        }

        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(10, 20, 40, 0.3);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, rgba(100, 150, 255, 0.5), rgba(150, 100, 255, 0.5));
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, rgba(100, 150, 255, 0.8), rgba(150, 100, 255, 0.8));
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 1000;
        }

        .spinner {
            border: 4px solid rgba(100, 200, 255, 0.1);
            border-top: 4px solid #6cf;
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
            margin: 20px auto;
            box-shadow: 0 0 20px rgba(100, 200, 255, 0.3);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .cosmic-title {
            font-size: 32px;
            background: linear-gradient(135deg, #6cf, #96f, #6cf);
            background-size: 200% 200%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradientShift 3s ease infinite;
            text-shadow: 0 0 30px rgba(100, 200, 255, 0.5);
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .hint {
            font-size: 11px;
            color: rgba(200, 220, 255, 0.6);
            margin-top: 5px;
            font-style: italic;
        }

        option {
            background: #0a1020;
            color: #e0f0ff;
        }

        .glow-text {
            animation: pulse 2s ease-in-out infinite;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    
    <div id="loading">
        <div class="cosmic-title">‚àû INFINITY UNIVERSE</div>
        <div class="spinner"></div>
        <div class="glow-text">–ò—Å—Å–ª–µ–¥—É—è –Ω–µ–∏–∑–≤–µ–¥–∞–Ω–Ω–æ–µ...</div>
    </div>

    <div id="controls" class="ui-panel">
        <h3>‚ö° –ù–∞–≤–∏–≥–∞—Ü–∏—è</h3>
        
        <div class="control-group">
            <strong>üéµ –ó–≤—É–∫–æ–≤–æ–π –ü–æ—Ä—Ç–∞–ª</strong>
            <input type="file" id="audioFile" accept="audio/*">
            <button onclick="startMicrophone()">üé§ –ú–∏–∫—Ä–æ—Ñ–æ–Ω</button>
            <button onclick="generateAmbient()">üåä Cosmic Ambient</button>
            <button onclick="toggleAudio()">‚èØ –ü–∞—É–∑–∞</button>
            <div class="hint">–ú—É–∑—ã–∫–∞ –æ–∂–∏–≤–∏—Ç –≤—Å–µ–ª–µ–Ω–Ω—É—é</div>
        </div>

        <div class="control-group">
            <strong>üì∑ –†–µ–∂–∏–º –ó—Ä–µ–Ω–∏—è</strong>
            <select id="cameraMode" onchange="changeCameraMode(this.value)">
                <option value="free">üöÄ –°–≤–æ–±–æ–¥–Ω—ã–π –ø–æ–ª–µ—Ç</option>
                <option value="orbit">üåç –û—Ä–±–∏—Ç–∞–ª—å–Ω–∞—è —Å—ä–µ–º–∫–∞</option>
                <option value="cinematic">üé¨ –ö–∏–Ω–µ–º–∞—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏–π</option>
                <option value="galaxy">üåå –ì–∞–ª–∞–∫—Ç–∏—á–µ—Å–∫–∏–π –æ–±–∑–æ—Ä</option>
            </select>
        </div>

        <div class="control-group">
            <strong>üé® –ó–≤—É–∫–æ–≤–æ–π –°–ø–µ–∫—Ç—Ä</strong>
            <select id="musicMode" onchange="changeMusicMode(this.value)">
                <option value="normal">‚ú® –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π</option>
                <option value="symphonic">üéª –°–∏–º—Ñ–æ–Ω–∏—á–µ—Å–∫–∏–π</option>
                <option value="electronic">‚ö° –≠–ª–µ–∫—Ç—Ä–æ–Ω–Ω—ã–π</option>
                <option value="ambient">üåä –≠–º–±–∏–µ–Ω—Ç</option>
                <option value="rock">üî• –†–æ–∫/–ú–µ—Ç–∞–ª</option>
                <option value="jazz">üé∑ –î–∂–∞–∑</option>
            </select>
        </div>

        <div class="control-group">
            <strong>‚è± –í—Ä–µ–º–µ–Ω–Ω–æ–π –ü–æ—Ç–æ–∫: <span id="timeSpeed" class="glow-text">1.0</span>x</strong>
            <input type="range" id="timeSlider" min="-10" max="30" value="0" step="1" oninput="changeTimeSpeed(this.value)">
            <div class="hint">–£–ø—Ä–∞–≤–ª—è–π—Ç–µ —Ç–µ—á–µ–Ω–∏–µ–º –≤—Ä–µ–º–µ–Ω–∏</div>
        </div>

        <div class="control-group">
            <button onclick="hyperJump()">‚ö° –ì–∏–ø–µ—Ä–ø—Ä—ã–∂–æ–∫</button>
            <button onclick="saveBookmark()">‚≠ê –ó–∞–∫–ª–∞–¥–∫–∞</button>
            <button onclick="screenshot()">üì∏ –°–Ω–∏–º–æ–∫</button>
            <button onclick="toggleUI()">üëÅ UI</button>
        </div>

        <div class="control-group">
            <strong>üìä –ñ—É—Ä–Ω–∞–ª –ü—É—Ç–µ—à–µ—Å—Ç–≤–∏–π</strong>
            <div class="stat-line">
                <span class="stat-label">–°–∏—Å—Ç–µ–º –ø–æ—Å–µ—â–µ–Ω–æ:</span>
                <span id="systemsVisited" class="glow-text">0</span>
            </div>
            <div class="stat-line">
                <span class="stat-label">–ó–≤–µ–∑–¥ –æ—Ç–∫—Ä—ã—Ç–æ:</span>
                <span id="starsFound" class="glow-text">0</span>
            </div>
            <div class="stat-line">
                <span class="stat-label">–î–∏—Å—Ç–∞–Ω—Ü–∏—è:</span>
                <span id="distanceTraveled" class="glow-text">0 —Å–≤. –ª–µ—Ç</span>
            </div>
        </div>
    </div>

    <div id="info" class="ui-panel">
        <h3 id="objectName">‚ú® –¢–∞–π–Ω—ã –ö–æ—Å–º–æ—Å–∞</h3>
        <div id="objectInfo">
            <p style="color: rgba(200, 220, 255, 0.7); line-height: 1.6;">
                –ü–µ—Ä–µ–¥ –≤–∞–º–∏ –±–µ—Å–∫–æ–Ω–µ—á–Ω–∞—è –ø—Ä–æ—Ü–µ–¥—É—Ä–Ω–æ-–≥–µ–Ω–µ—Ä–∏—Ä—É–µ–º–∞—è –≤—Å–µ–ª–µ–Ω–Ω–∞—è. 
                –ö–∞–∂–¥–∞—è –∑–≤–µ–∑–¥–∞ —É–Ω–∏–∫–∞–ª—å–Ω–∞, –∫–∞–∂–¥–∞—è —Å–∏—Å—Ç–µ–º–∞ - –Ω–µ–ø–æ–≤—Ç–æ—Ä–∏–º–∞.
            </p>
            <br>
            <div class="stat-line">
                <span class="stat-label">üñ± –í—Ä–∞—â–µ–Ω–∏–µ</span>
                <span>–õ–ö–ú + Drag</span>
            </div>
            <div class="stat-line">
                <span class="stat-label">üîç –ú–∞—Å—à—Ç–∞–±</span>
                <span>–ö–æ–ª–µ—Å–æ –º—ã—à–∏</span>
            </div>
            <div class="stat-line">
                <span class="stat-label">üéØ –í—ã–±–æ—Ä</span>
                <span>–ö–ª–∏–∫ –ø–æ –æ–±—ä–µ–∫—Ç—É</span>
            </div>
            <div class="stat-line">
                <span class="stat-label">‚å® –î–≤–∏–∂–µ–Ω–∏–µ</span>
                <span>WASD / –°—Ç—Ä–µ–ª–∫–∏</span>
            </div>
            <div class="stat-line">
                <span class="stat-label">‚ö° –£—Å–∫–æ—Ä–µ–Ω–∏–µ</span>
                <span>Shift</span>
            </div>
            <div class="stat-line">
                <span class="stat-label">‚è∏ –ü–∞—É–∑–∞</span>
                <span>–ü—Ä–æ–±–µ–ª</span>
            </div>
        </div>
    </div>

    <div id="spectrum" class="ui-panel">
        <canvas id="spectrumCanvas"></canvas>
    </div>

    <div id="minimap" class="ui-panel">
        <canvas id="minimapCanvas"></canvas>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // === –ì–õ–û–ë–ê–õ–¨–ù–´–ï –ü–ï–†–ï–ú–ï–ù–ù–´–ï ===
        let scene, camera, renderer, audioContext, analyser, dataArray;
        let stars = [], planets = [], selectedObject = null;
        let cameraMode = 'free', musicMode = 'normal';
        let timeScale = 1.0, stats = {systems: 0, stars: 0, distance: 0};
        let clock = new THREE.Clock();
        let audioSource = null, isAudioPlaying = false;
        let mouseDown = false, mouseX = 0, mouseY = 0;
        let cameraRotation = {x: 0, y: 0};
        let cameraPosition = new THREE.Vector3(0, 50, 150);
        let cameraVelocity = new THREE.Vector3();
        let keys = {};
        let currentSeed = Math.random().toString(36).substr(2, 9);
        let starfield, nebulae = [], dustParticles;
        let infiniteStars = new Map();
        let lastCameraChunk = {x: 0, y: 0, z: 0};
        const CHUNK_SIZE = 500;
        const RENDER_DISTANCE = 3;

        // === –ò–ù–ò–¶–ò–ê–õ–ò–ó–ê–¶–ò–Ø ===
        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000511, 0.0003);
            
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('canvas'),
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            
            camera.position.copy(cameraPosition);

            // –û—Å–≤–µ—â–µ–Ω–∏–µ
            const ambientLight = new THREE.AmbientLight(0x1a2344, 0.4);
            scene.add(ambientLight);

            // –§–æ–Ω - –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ–µ –∑–≤–µ–∑–¥–Ω–æ–µ –ø–æ–ª–µ
            createInfiniteStarfield();
            
            // –ß–∞—Å—Ç–∏—Ü—ã –∫–æ—Å–º–∏—á–µ—Å–∫–æ–π –ø—ã–ª–∏
            createCosmicDust();
            
            // –¢—É–º–∞–Ω–Ω–æ—Å—Ç–∏
            createNebulae();

            // –ê—É–¥–∏–æ
            setupAudio();

            // –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø–µ—Ä–≤–æ–π —Å–∏—Å—Ç–µ–º—ã
            generateStarSystem();

            // –°–æ–±—ã—Ç–∏—è
            setupEvents();

            // –ó–∞–ø—É—Å–∫
            setTimeout(() => {
                document.getElementById('loading').style.opacity = '0';
                document.getElementById('loading').style.transition = 'opacity 1s';
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 1000);
            }, 2000);
            
            animate();
        }

        // === –ë–ï–°–ö–û–ù–ï–ß–ù–û–ï –ó–í–ï–ó–î–ù–û–ï –ü–û–õ–ï ===
        function createInfiniteStarfield() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            const colors = [];
            const sizes = [];
            
            for (let i = 0; i < 10000; i++) {
                vertices.push(
                    (Math.random() - 0.5) * 3000,
                    (Math.random() - 0.5) * 3000,
                    (Math.random() - 0.5) * 3000
                );
                
                const color = new THREE.Color();
                const temp = Math.random();
                if (temp < 0.2) color.setHex(0x9bb0ff); // –ì–æ–ª—É–±—ã–µ
                else if (temp < 0.4) color.setHex(0xaabfff); // –ë–µ–ª–æ-–≥–æ–ª—É–±—ã–µ
                else if (temp < 0.6) color.setHex(0xfff4ea); // –ñ–µ–ª—Ç—ã–µ
                else if (temp < 0.8) color.setHex(0xffd2a1); // –û—Ä–∞–Ω–∂–µ–≤—ã–µ
                else color.setHex(0xffcc6f); // –ö—Ä–∞—Å–Ω—ã–µ
                
                colors.push(color.r, color.g, color.b);
                sizes.push(Math.random() * 2 + 0.5);
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));
            
            const material = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 }
                },
                vertexShader: `
                    attribute float size;
                    attribute vec3 color;
                    varying vec3 vColor;
                    varying float vAlpha;
                    uniform float time;
                    
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        
                        // –ú–µ—Ä—Ü–∞–Ω–∏–µ
                        float flicker = sin(time * 2.0 + position.x * 0.01) * 0.3 + 0.7;
                        vAlpha = flicker;
                        
                        gl_PointSize = size * (300.0 / -mvPosition.z) * flicker;
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    varying float vAlpha;
                    
                    void main() {
                        float dist = length(gl_PointCoord - vec2(0.5));
                        if (dist > 0.5) discard;
                        
                        float alpha = (1.0 - dist * 2.0) * vAlpha;
                        gl_FragColor = vec4(vColor, alpha);
                    }
                `,
                transparent: true,
                vertexColors: true,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });
            
            starfield = new THREE.Points(geometry, material);
            scene.add(starfield);
        }

        // === –ö–û–°–ú–ò–ß–ï–°–ö–ê–Ø –ü–´–õ–¨ ===
        function createCosmicDust() {
            const geometry = new THREE.BufferGeometry();
            const vertices = [];
            
            for (let i = 0; i < 3000; i++) {
                vertices.push(
                    (Math.random() - 0.5) * 2000,
                    (Math.random() - 0.5) * 2000,
                    (Math.random() - 0.5) * 2000
                );
            }
            
            geometry.setAttribute('position', new THREE.Float32BufferAttribute(vertices, 3));
            
            const material = new THREE.PointsMaterial({
                color: 0x6699ff,
                size: 0.3,
                transparent: true,
                opacity: 0.3,
                blending: THREE.AdditiveBlending
            });
            
            dustParticles = new THREE.Points(geometry, material);
            scene.add(dustParticles);
        }

        // === –¢–£–ú–ê–ù–ù–û–°–¢–ò ===
        function createNebulae() {
            for (let i = 0; i < 3; i++) {
                const geometry = new THREE.SphereGeometry(150, 32, 32);
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        color1: { value: new THREE.Color(0x1a4d7a) },
                        color2: { value: new THREE.Color(0x7a1a4d) }
                    },
                    vertexShader: `
                        varying vec3 vNormal;
                        varying vec3 vPosition;
                        void main() {
                            vNormal = normalize(normalMatrix * normal);
                            vPosition = position;
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform vec3 color1;
                        uniform vec3 color2;
                        varying vec3 vNormal;
                        varying vec3 vPosition;
                        
                        void main() {
                            float noise = sin(vPosition.x * 0.01 + time) * 
                                         cos(vPosition.y * 0.01 + time) * 
                                         sin(vPosition.z * 0.01 + time);
                            vec3 color = mix(color1, color2, noise * 0.5 + 0.5);
                            float alpha = 0.1 + abs(noise) * 0.1;
                            gl_FragColor = vec4(color, alpha);
                        }
                    `,
                    transparent: true,
                    side: THREE.BackSide,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                const nebula = new THREE.Mesh(geometry, material);
                nebula.position.set(
                    (Math.random() - 0.5) * 800,
                    (Math.random() - 0.5) * 400,
                    (Math.random() - 0.5) * 800
                );
                scene.add(nebula);
                nebulae.push(nebula);
            }
        }

        // === –ì–ï–ù–ï–†–ê–¶–ò–Ø –ó–í–ï–ó–î–ù–û–ô –°–ò–°–¢–ï–ú–´ ===
        function generateStarSystem() {
            stars.forEach(s => {
                scene.remove(s.mesh);
                scene.remove(s.coronaRays);
            });
            planets.forEach(p => scene.remove(p.mesh));
            stars = [];
            planets = [];

            const starTypes = [
                {class: 'O', color: 0x9bb0ff, temp: 30000, size: 15, freq: [6000, 20000]},
                {class: 'B', color: 0xaabfff, temp: 18000, size: 10, freq: [4000, 10000]},
                {class: 'A', color: 0xcad7ff, temp: 8500, size: 7, freq: [2000, 6000]},
                {class: 'G', color: 0xfff4ea, temp: 5800, size: 5, freq: [500, 2000]},
                {class: 'K', color: 0xffd2a1, temp: 4500, size: 4, freq: [250, 500]},
                {class: 'M', color: 0xffcc6f, temp: 3000, size: 3, freq: [60, 250]}
            ];

            let starType = starTypes[Math.floor(Math.random() * starTypes.length)];

            // –ó–≤–µ–∑–¥–∞
            const starGeometry = new THREE.SphereGeometry(starType.size, 64, 64);
            const starMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    baseColor: { value: new THREE.Color(starType.color) },
                    intensity: { value: 1.0 }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    uniform float time;
                    
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vPosition = position;
                        
                        vec3 pos = position;
                        float displacement = sin(pos.x * 0.5 + time) * cos(pos.y * 0.5 + time) * 0.3;
                        pos += normal * displacement;
                        
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 baseColor;
                    uniform float intensity;
                    uniform float time;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    
                    void main() {
                        float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 2.0);
                        float pulse = sin(time * 2.0) * 0.1 + 0.9;
                        vec3 glow = baseColor * (intensity * pulse + fresnel * 0.5);
                        gl_FragColor = vec4(glow, 1.0);
                    }
                `,
                side: THREE.FrontSide
            });
            
            const starMesh = new THREE.Mesh(starGeometry, starMaterial);
            scene.add(starMesh);

            // –ö–æ—Ä–æ–Ω–∞–ª—å–Ω—ã–µ –ª—É—á–∏
            const raysGeometry = new THREE.SphereGeometry(starType.size * 2, 32, 32);
            const raysMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    color: { value: new THREE.Color(starType.color) }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;
                    uniform float time;
                    varying vec3 vNormal;
                    
                    void main() {
                        float intensity = pow(0.7 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 3.0);
                        float pulse = sin(time) * 0.2 + 0.8;
                        gl_FragColor = vec4(color, intensity * 0.4 * pulse);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide,
                depthWrite: false
            });
            
            const coronaRays = new THREE.Mesh(raysGeometry, raysMaterial);
            scene.add(coronaRays);

            // –¢–æ—á–µ—á–Ω—ã–π —Å–≤–µ—Ç –æ—Ç –∑–≤–µ–∑–¥—ã
            const pointLight = new THREE.PointLight(starType.color, 2, 300);
            starMesh.add(pointLight);

            const starName = generateStarName();
            stars.push({
                mesh: starMesh,
                coronaRays: coronaRays,
                type: starType,
                name: starName,
                baseSize: starType.size,
                freqRange: starType.freq,
                material: starMaterial,
                raysMaterial: raysMaterial
            });

            // –ü–ª–∞–Ω–µ—Ç—ã
            const numPlanets = musicMode === 'symphonic' ? 8 + Math.floor(Math.random() * 5) : 3 + Math.floor(Math.random() * 6);
            for (let i = 0; i < numPlanets; i++) {
                generatePlanet(i, starType);
            }

            stats.systems++;
            stats.stars++;
            updateStats();
        }

        // === –ì–ï–ù–ï–†–ê–¶–ò–Ø –ü–õ–ê–ù–ï–¢–´ ===
        function generatePlanet(index, starType) {
            const planetTypes = [
                {type: 'Rocky', colors: [0x8b7355, 0x6b5345], size: [0.8, 2], glow: false},
                {type: 'Gas Giant', colors: [0xd4a574, 0xc49464], size: [3, 6], glow: true},
                {type: 'Ice Giant', colors: [0x4fc3f7, 0x3fb3e7], size: [2.5, 4], glow: true},
                {type: 'Lava World', colors: [0xff4500, 0xff6a00], size: [0.7, 1.5], glow: true},
                {type: 'Ocean', colors: [0x006994, 0x005984], size: [0.9, 2.2], glow: false},
                {type: 'Crystalline', colors: [0xaa00ff, 0xcc44ff], size: [1, 2], glow: true}
            ];

            const planetType = planetTypes[Math.floor(Math.random() * planetTypes.length)];
            const size = planetType.size[0] + Math.random() * (planetType.size[1] - planetType.size[0]);
            
            const planetGeometry = new THREE.SphereGeometry(size, 32, 32);
            const planetMaterial = new THREE.MeshStandardMaterial({
                color: planetType.colors[0],
                roughness: 0.8,
                metalness: planetType.type === 'Crystalline' ? 0.9 : 0.2,
                emissive: planetType.glow ? planetType.colors[1] : 0x000000,
                emissiveIntensity: planetType.glow ? 0.3 : 0
            });
            const planetMesh = new THREE.Mesh(planetGeometry, planetMaterial);

            const orbitRadius = 20 + index * 15 + Math.random() * 10;
            const orbitSpeed = (0.001 / (orbitRadius * 0.1));
            const orbitAngle = Math.random() * Math.PI * 2;
            const orbitInclination = (Math.random() - 0.5) * 0.3;
            
            planetMesh.position.x = Math.cos(orbitAngle) * orbitRadius;
            planetMesh.position.z = Math.sin(orbitAngle) * orbitRadius;
            planetMesh.position.y = Math.sin(orbitInclination) * orbitRadius * 0.2;

            scene.add(planetMesh);

            // –ê—Ç–º–æ—Å—Ñ–µ—Ä–∞ —Å —Å–≤–µ—á–µ–Ω–∏–µ–º
            if (planetType.glow) {
                const atmGeometry = new THREE.SphereGeometry(size * 1.15, 32, 32);
                const atmMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        color: { value: new THREE.Color(planetType.colors[0]) }
                    },
                    vertexShader: `
                        varying vec3 vNormal;
                        void main() {
                            vNormal = normalize(normalMatrix * normal);
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 color;
                        varying vec3 vNormal;
                        void main() {
                            float intensity = pow(0.6 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
                            gl_FragColor = vec4(color, intensity * 0.5);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    side: THREE.BackSide
                });
                const atmosphere = new THREE.Mesh(atmGeometry, atmMaterial);
                planetMesh.add(atmosphere);
            }

            // –ö–æ–ª—å—Ü–∞
            if (planetType.type === 'Gas Giant' && Math.random() > 0.5) {
                const ringGeometry = new THREE.RingGeometry(size * 1.5, size * 2.5, 64);
                const ringMaterial = new THREE.MeshBasicMaterial({
                    color: 0xccaa88,
                    side: THREE.DoubleSide,
                    transparent: true,
                    opacity: 0.6
                });
                const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                ring.rotation.x = Math.PI / 2;
                planetMesh.add(ring);
            }

            const planetName = generatePlanetName(index);
            planets.push({
                mesh: planetMesh,
                type: planetType.type,
                name: planetName,
                orbit: {radius: orbitRadius, speed: orbitSpeed, angle: orbitAngle, inclination: orbitInclination},
                size: size,
                baseY: planetMesh.position.y
            });
        }

        // === –ì–ï–ù–ï–†–ê–¶–ò–Ø –ò–ú–ï–ù ===
        function generateStarName() {
            const prefixes = ['Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Sigma', 'Omega'];
            const suffixes = ['Centauri', 'Draconis', 'Phoenicis', 'Aquilae', 'Lyrae', 'Orionis', 'Cygni'];
            return `${prefixes[Math.floor(Math.random() * prefixes.length)]} ${suffixes[Math.floor(Math.random() * suffixes.length)]}`;
        }

        function generatePlanetName(index) {
            const letters = ['b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k'];
            return `${stars[0].name} ${letters[index]}`;
        }

        // === –ê–£–î–ò–û ===
        function setupAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;
            analyser.smoothingTimeConstant = 0.8;
            dataArray = new Uint8Array(analyser.frequencyBinCount);
            analyser.connect(audioContext.destination);

            document.getElementById('audioFile').addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file) {
                    const reader = new FileReader();
                    reader.onload = function(event) {
                        audioContext.decodeAudioData(event.target.result, function(buffer) {
                            if (audioSource) audioSource.stop();
                            audioSource = audioContext.createBufferSource();
                            audioSource.buffer = buffer;
                            audioSource.connect(analyser);
                            audioSource.loop = true;
                            audioSource.start(0);
                            isAudioPlaying = true;
                        });
                    };
                    reader.readAsArrayBuffer(file);
                }
            });
        }

        function startMicrophone() {
            navigator.mediaDevices.getUserMedia({audio: true})
                .then(stream => {
                    if (audioSource) audioSource.stop();
                    audioSource = audioContext.createMediaStreamSource(stream);
                    audioSource.connect(analyser);
                    isAudioPlaying = true;
                })
                .catch(err => alert('–ú–∏–∫—Ä–æ—Ñ–æ–Ω –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω'));
        }

        function generateAmbient() {
            if (audioSource && audioSource.stop) audioSource.stop();
            
            const osc1 = audioContext.createOscillator();
            const osc2 = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();
            
            osc1.type = 'sine';
            osc2.type = 'triangle';
            osc1.frequency.value = 110;
            osc2.frequency.value = 220;
            filter.type = 'lowpass';
            filter.frequency.value = 800;
            gainNode.gain.value = 0.2;
            
            osc1.connect(filter);
            osc2.connect(filter);
            filter.connect(gainNode);
            gainNode.connect(analyser);
            
            osc1.start();
            osc2.start();
            audioSource = {osc1, osc2, stop: () => { osc1.stop(); osc2.stop(); }};
            isAudioPlaying = true;

            setInterval(() => {
                if (audioSource.osc1) {
                    osc1.frequency.value = 80 + Math.random() * 200;
                    osc2.frequency.value = 150 + Math.random() * 300;
                }
            }, 4000);
        }

        function toggleAudio() {
            if (audioContext.state === 'running') {
                audioContext.suspend();
            } else {
                audioContext.resume();
            }
        }

        // === –û–ë–†–ê–ë–û–¢–ö–ê –ê–£–î–ò–û ===
        function processAudio() {
            if (!analyser) return;
            
            analyser.getByteFrequencyData(dataArray);

            const bass = getAverageFrequency(0, 250, dataArray) / 255;
            const mid = getAverageFrequency(250, 2000, dataArray) / 255;
            const high = getAverageFrequency(2000, 20000, dataArray) / 255;

            // –ú–µ—Ä—Ü–∞–Ω–∏–µ –∑–≤–µ–∑–¥
            stars.forEach(star => {
                const freqValue = (bass + mid + high) / 3;
                star.material.uniforms.intensity.value = 0.8 + freqValue * 0.4;
                star.raysMaterial.uniforms.time.value += 0.01;
                
                // –ü–ª–∞–≤–Ω–∞—è –ø—É–ª—å—Å–∞—Ü–∏—è
                const targetScale = 1 + freqValue * 0.15;
                star.mesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);
                star.coronaRays.scale.copy(star.mesh.scale);
            });

            // –†–µ–∞–∫—Ü–∏—è –ø–ª–∞–Ω–µ—Ç
            planets.forEach(planet => {
                const targetY = planet.baseY + bass * 3;
                planet.mesh.position.y += (targetY - planet.mesh.position.y) * 0.1;
                planet.mesh.rotation.y += 0.005 * (1 + mid);
            });

            drawSpectrum(dataArray);
        }

        function getAverageFrequency(startFreq, endFreq, dataArray) {
            const nyquist = audioContext.sampleRate / 2;
            const startBin = Math.floor(startFreq / nyquist * dataArray.length);
            const endBin = Math.floor(endFreq / nyquist * dataArray.length);
            
            let sum = 0;
            for (let i = startBin; i < endBin; i++) {
                sum += dataArray[i];
            }
            return sum / (endBin - startBin);
        }

        // === –°–ü–ï–ö–¢–†–û–ì–†–ê–ú–ú–ê ===
        function drawSpectrum(dataArray) {
            const canvas = document.getElementById('spectrumCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, 'rgba(100, 200, 255, 0.1)');
            gradient.addColorStop(1, 'rgba(150, 100, 255, 0.1)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const barWidth = canvas.width / (dataArray.length / 2);
            
            for (let i = 0; i < dataArray.length / 2; i++) {
                const barHeight = (dataArray[i] / 255) * canvas.height * 0.9;
                const hue = 200 + (i / (dataArray.length / 2)) * 60;
                const gradient = ctx.createLinearGradient(0, canvas.height - barHeight, 0, canvas.height);
                gradient.addColorStop(0, `hsla(${hue}, 80%, 60%, 0.9)`);
                gradient.addColorStop(1, `hsla(${hue}, 80%, 40%, 0.4)`);
                ctx.fillStyle = gradient;
                ctx.fillRect(i * barWidth, canvas.height - barHeight, barWidth - 1, barHeight);
            }
        }

        // === –ú–ò–ù–ò–ö–ê–†–¢–ê ===
        function drawMinimap() {
            const canvas = document.getElementById('minimapCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            const gradient = ctx.createRadialGradient(canvas.width/2, canvas.height/2, 0, canvas.width/2, canvas.height/2, canvas.width/2);
            gradient.addColorStop(0, 'rgba(10, 20, 50, 0.9)');
            gradient.addColorStop(1, 'rgba(5, 10, 30, 0.95)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const scale = 0.6;

            // –ó–≤–µ–∑–¥–∞
            const starGrad = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 8);
            starGrad.addColorStop(0, 'rgba(255, 255, 100, 1)');
            starGrad.addColorStop(1, 'rgba(255, 200, 100, 0)');
            ctx.fillStyle = starGrad;
            ctx.beginPath();
            ctx.arc(centerX, centerY, 8, 0, Math.PI * 2);
            ctx.fill();

            // –ü–ª–∞–Ω–µ—Ç—ã —Å –æ—Ä–±–∏—Ç–∞–º–∏
            planets.forEach(planet => {
                const x = centerX + planet.mesh.position.x * scale;
                const y = centerY + planet.mesh.position.z * scale;
                
                // –û—Ä–±–∏—Ç–∞
                ctx.strokeStyle = 'rgba(100, 200, 255, 0.2)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.arc(centerX, centerY, planet.orbit.radius * scale, 0, Math.PI * 2);
                ctx.stroke();
                
                // –ü–ª–∞–Ω–µ—Ç–∞
                const planetGrad = ctx.createRadialGradient(x, y, 0, x, y, 3);
                planetGrad.addColorStop(0, 'rgba(100, 200, 255, 1)');
                planetGrad.addColorStop(1, 'rgba(100, 200, 255, 0)');
                ctx.fillStyle = planetGrad;
                ctx.beginPath();
                ctx.arc(x, y, 3, 0, Math.PI * 2);
                ctx.fill();
            });

            // –ö–∞–º–µ—Ä–∞
            const camGrad = ctx.createRadialGradient(centerX, centerY, 0, centerX, centerY, 5);
            camGrad.addColorStop(0, 'rgba(0, 255, 100, 1)');
            camGrad.addColorStop(1, 'rgba(0, 255, 100, 0)');
            ctx.fillStyle = camGrad;
            const camX = centerX + camera.position.x * scale * 0.1;
            const camY = centerY + camera.position.z * scale * 0.1;
            ctx.beginPath();
            ctx.arc(camX, camY, 4, 0, Math.PI * 2);
            ctx.fill();
        }

        // === –°–û–ë–´–¢–ò–Ø ===
        function setupEvents() {
            window.addEventListener('resize', onResize);
            
            const canvas = document.getElementById('canvas');
            canvas.addEventListener('mousedown', onMouseDown);
            canvas.addEventListener('mousemove', onMouseMove);
            canvas.addEventListener('mouseup', onMouseUp);
            canvas.addEventListener('wheel', onWheel);
            canvas.addEventListener('click', onClick);
            
            window.addEventListener('keydown', e => {
                keys[e.key] = true;
                if (e.key === ' ') toggleAudio();
            });
            window.addEventListener('keyup', e => keys[e.key] = false);
        }

        function onResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseDown(e) {
            mouseDown = true;
            mouseX = e.clientX;
            mouseY = e.clientY;
        }

        function onMouseMove(e) {
            if (!mouseDown || cameraMode !== 'free') return;
            
            const deltaX = e.clientX - mouseX;
            const deltaY = e.clientY - mouseY;
            
            cameraRotation.y -= deltaX * 0.003;
            cameraRotation.x -= deltaY * 0.003;
            cameraRotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraRotation.x));
            
            mouseX = e.clientX;
            mouseY = e.clientY;
        }

        function onMouseUp() {
            mouseDown = false;
        }

        function onWheel(e) {
            e.preventDefault();
            const delta = e.deltaY * 0.001;
            cameraVelocity.z += delta * 5;
        }

        function onClick(e) {
            if (mouseDown) return;
            
            const mouse = new THREE.Vector2(
                (e.clientX / window.innerWidth) * 2 - 1,
                -(e.clientY / window.innerHeight) * 2 + 1
            );

            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(mouse, camera);

            const allObjects = [...stars.map(s => s.mesh), ...planets.map(p => p.mesh)];
            const intersects = raycaster.intersectObjects(allObjects);

            if (intersects.length > 0) {
                selectObject(intersects[0].object);
            }
        }

        function selectObject(mesh) {
            selectedObject = null;
            
            stars.forEach(star => {
                if (star.mesh === mesh) {
                    selectedObject = star;
                    displayStarInfo(star);
                }
            });
            
            planets.forEach(planet => {
                if (planet.mesh === mesh) {
                    selectedObject = planet;
                    displayPlanetInfo(planet);
                }
            });
        }

        function displayStarInfo(star) {
            document.getElementById('objectName').textContent = `‚≠ê ${star.name}`;
            document.getElementById('objectInfo').innerHTML = `
                <div class="stat-line"><span class="stat-label">–ö–ª–∞—Å—Å:</span><span>${star.type.class}</span></div>
                <div class="stat-line"><span class="stat-label">–¢–µ–º–ø–µ—Ä–∞—Ç—É—Ä–∞:</span><span>${star.type.temp.toLocaleString()} K</span></div>
                <div class="stat-line"><span class="stat-label">–†–∞–¥–∏—É—Å:</span><span>${star.baseSize.toFixed(1)} R‚òâ</span></div>
                <div class="stat-line"><span class="stat-label">–ß–∞—Å—Ç–æ—Ç—ã:</span><span>${star.freqRange[0]}-${star.freqRange[1]} Hz</span></div>
                <br>
                <p style="color: rgba(200, 220, 255, 0.7); font-size: 12px; line-height: 1.5;">
                    –≠—Ç–∞ –∑–≤–µ–∑–¥–∞ —Ä–µ–∞–≥–∏—Ä—É–µ—Ç –Ω–∞ –∑–≤—É–∫–æ–≤—ã–µ —á–∞—Å—Ç–æ—Ç—ã –≤ –¥–∏–∞–ø–∞–∑–æ–Ω–µ ${star.freqRange[0]}-${star.freqRange[1]} –ì—Ü.
                    –ï—ë —Å–≤–µ—á–µ–Ω–∏–µ —É—Å–∏–ª–∏–≤–∞–µ—Ç—Å—è –ø—Ä–∏ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏—Ö —á–∞—Å—Ç–æ—Ç–∞—Ö –≤ –º—É–∑—ã–∫–µ.
                </p>
            `;
        }

        function displayPlanetInfo(planet) {
            document.getElementById('objectName').textContent = `ü™ê ${planet.name}`;
            document.getElementById('objectInfo').innerHTML = `
                <div class="stat-line"><span class="stat-label">–¢–∏–ø:</span><span>${planet.type}</span></div>
                <div class="stat-line"><span class="stat-label">–†–∞–¥–∏—É—Å:</span><span>${planet.size.toFixed(2)} Rüú®</span></div>
                <div class="stat-line"><span class="stat-label">–û—Ä–±–∏—Ç–∞:</span><span>${planet.orbit.radius.toFixed(1)} –∞.–µ.</span></div>
                <div class="stat-line"><span class="stat-label">–ü–µ—Ä–∏–æ–¥:</span><span>${(Math.sqrt(Math.pow(planet.orbit.radius, 3)) * 365).toFixed(0)} –¥–Ω–µ–π</span></div>
                <br>
                <p style="color: rgba(200, 220, 255, 0.7); font-size: 12px; line-height: 1.5;">
                    –ü–ª–∞–Ω–µ—Ç–∞ ${planet.type.toLowerCase()}-—Ç–∏–ø–∞, –æ–±—Ä–∞—â–∞—é—â–∞—è—Å—è –≤–æ–∫—Ä—É–≥ –∑–≤–µ–∑–¥—ã ${stars[0]?.name}.
                    –í—ã—Å–æ—Ç–∞ –æ—Ä–±–∏—Ç—ã –º–µ–Ω—è–µ—Ç—Å—è –≤ —Ç–∞–∫—Ç –±–∞—Å–æ–≤—ã–º —á–∞—Å—Ç–æ—Ç–∞–º –º—É–∑—ã–∫–∏.
                </p>
            `;
        }

        // === –£–ü–†–ê–í–õ–ï–ù–ò–ï –ö–ê–ú–ï–†–û–ô ===
        function handleCameraMovement() {
            const speed = (keys['Shift'] ? 3 : 1) * timeScale;
            
            if (cameraMode === 'free') {
                const forward = new THREE.Vector3(
                    Math.sin(cameraRotation.y),
                    0,
                    Math.cos(cameraRotation.y)
                );
                const right = new THREE.Vector3(
                    Math.cos(cameraRotation.y),
                    0,
                    -Math.sin(cameraRotation.y)
                );

                if (keys['w'] || keys['W'] || keys['ArrowUp']) cameraVelocity.add(forward.multiplyScalar(speed * 0.5));
                if (keys['s'] || keys['S'] || keys['ArrowDown']) cameraVelocity.add(forward.multiplyScalar(-speed * 0.5));
                if (keys['a'] || keys['A'] || keys['ArrowLeft']) cameraVelocity.add(right.multiplyScalar(-speed * 0.5));
                if (keys['d'] || keys['D'] || keys['ArrowRight']) cameraVelocity.add(right.multiplyScalar(speed * 0.5));
                if (keys['q'] || keys['Q']) cameraVelocity.y += speed * 0.5;
                if (keys['e'] || keys['E']) cameraVelocity.y -= speed * 0.5;

                // –ò–Ω–µ—Ä—Ü–∏—è
                cameraVelocity.multiplyScalar(0.9);
                cameraPosition.add(cameraVelocity);

                camera.position.copy(cameraPosition);
                camera.rotation.order = 'YXZ';
                camera.rotation.y = cameraRotation.y;
                camera.rotation.x = cameraRotation.x;

                stats.distance += cameraVelocity.length() * 0.01;
            } else if (cameraMode === 'orbit' && selectedObject) {
                const distance = 30;
                const time = Date.now() * 0.0003;
                camera.position.x = selectedObject.mesh.position.x + Math.cos(time) * distance;
                camera.position.z = selectedObject.mesh.position.z + Math.sin(time) * distance;
                camera.position.y = selectedObject.mesh.position.y + 15;
                camera.lookAt(selectedObject.mesh.position);
            } else if (cameraMode === 'galaxy') {
                camera.position.set(0, 400, 0);
                camera.lookAt(0, 0, 0);
            } else if (cameraMode === 'cinematic') {
                const time = Date.now() * 0.0002;
                camera.position.x = Math.cos(time) * 200;
                camera.position.z = Math.sin(time) * 200;
                camera.position.y = 60 + Math.sin(time * 0.5) * 40;
                camera.lookAt(0, 0, 0);
            }
        }

        // === –û–ë–ù–û–í–õ–ï–ù–ò–ï –û–†–ë–ò–¢ ===
        function updateOrbits(delta) {
            planets.forEach(planet => {
                planet.orbit.angle += planet.orbit.speed * delta * timeScale;
                planet.mesh.position.x = Math.cos(planet.orbit.angle) * planet.orbit.radius;
                planet.mesh.position.z = Math.sin(planet.orbit.angle) * planet.orbit.radius;
            });
        }

        // === –ê–ù–ò–ú–ê–¶–ò–Ø ===
        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ —à–µ–π–¥–µ—Ä–æ–≤
            if (starfield) starfield.material.uniforms.time.value = time;
            nebulae.forEach(n => n.material.uniforms.time.value = time);
            stars.forEach(s => {
                s.material.uniforms.time.value = time;
                s.raysMaterial.uniforms.time.value = time;
            });
            
            // –í—Ä–∞—â–µ–Ω–∏–µ –∫–æ—Å–º–∏—á–µ—Å–∫–æ–π –ø—ã–ª–∏
            if (dustParticles) {
                dustParticles.rotation.y += 0.0001;
                dustParticles.rotation.x += 0.00005;
            }
            
            processAudio();
            handleCameraMovement();
            updateOrbits(delta);
            drawMinimap();
            
            renderer.render(scene, camera);
        }

        // === UI –§–£–ù–ö–¶–ò–ò ===
        function changeCameraMode(mode) {
            cameraMode = mode;
        }

        function changeMusicMode(mode) {
            musicMode = mode;
            generateStarSystem();
        }

        function changeTimeSpeed(value) {
            const v = parseFloat(value);
            timeScale = v < 0 ? Math.pow(10, v / 10) : Math.pow(10, v / 10);
            document.getElementById('timeSpeed').textContent = timeScale.toFixed(1);
        }

        function hyperJump() {
            const duration = 2000;
            const start = Date.now();
            const startPos = cameraPosition.clone();
            const targetPos = new THREE.Vector3(
                (Math.random() - 0.5) * 600,
                50 + (Math.random() - 0.5) * 100,
                (Math.random() - 0.5) * 600
            );
            
            function jump() {
                const progress = Math.min((Date.now() - start) / duration, 1);
                const eased = 1 - Math.pow(1 - progress, 3);
                cameraPosition.lerpVectors(startPos, targetPos, eased);
                
                if (progress < 1) {
                    requestAnimationFrame(jump);
                } else {
                    generateStarSystem();
                }
            }
            
            jump();
        }

        function saveBookmark() {
            alert(`–°–∏—Å—Ç–µ–º–∞ "${stars[0]?.name || '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è'}" —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∞ –≤ –∑–∞–∫–ª–∞–¥–∫–∏!`);
        }

        function screenshot() {
            renderer.render(scene, camera);
            const dataURL = renderer.domElement.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = `cosmos_${Date.now()}.png`;
            link.href = dataURL;
            link.click();
        }

        function toggleUI() {
            const panels = document.querySelectorAll('.ui-panel');
            panels.forEach(panel => {
                panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
            });
        }

        function updateStats() {
            document.getElementById('systemsVisited').textContent = stats.systems;
            document.getElementById('starsFound').textContent = stats.stars;
            document.getElementById('distanceTraveled').textContent = stats.distance.toFixed(2) + ' —Å–≤. –ª–µ—Ç';
        }

        // === –ó–ê–ü–£–°–ö ===
        window.addEventListener('load', init);
    </script>
</body>
</html>
