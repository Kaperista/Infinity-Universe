<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stellar Symphony</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@300;400;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Orbitron', sans-serif;
            overflow: hidden;
            background: #000;
            color: #fff;
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100vh;
        }

        .ui-panel {
            position: absolute;
            background: linear-gradient(135deg, rgba(10, 15, 35, 0.7), rgba(15, 25, 50, 0.5));
            backdrop-filter: blur(30px) saturate(200%);
            border: 1px solid rgba(100, 200, 255, 0.15);
            border-radius: 20px;
            padding: 25px;
            color: #e0f0ff;
            font-size: 13px;
            box-shadow: 0 15px 50px rgba(0, 100, 255, 0.15),
                        inset 0 2px 0 rgba(255, 255, 255, 0.1),
                        0 0 80px rgba(100, 150, 255, 0.05);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .ui-panel:hover {
            background: linear-gradient(135deg, rgba(15, 25, 50, 0.8), rgba(20, 35, 65, 0.6));
            border-color: rgba(100, 200, 255, 0.3);
            box-shadow: 0 20px 60px rgba(0, 150, 255, 0.25),
                        inset 0 2px 0 rgba(255, 255, 255, 0.15),
                        0 0 100px rgba(100, 150, 255, 0.1);
        }

        #controls {
            top: 30px;
            left: 30px;
            width: 380px;
            max-height: 90vh;
            overflow-y: auto;
        }

        #info {
            top: 30px;
            right: 30px;
            width: 400px;
            max-height: 90vh;
            overflow-y: auto;
        }

        #spectrum {
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 700px;
            height: 160px;
            padding: 20px;
        }

        #editor {
            display: none;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 1000;
        }

        h3 {
            margin: 0 0 20px 0;
            color: #6cf;
            font-size: 20px;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 3px;
            border-bottom: 3px solid;
            border-image: linear-gradient(90deg, #6cf, #96f, transparent) 1;
            padding-bottom: 12px;
            text-shadow: 0 0 20px rgba(100, 200, 255, 0.6),
                         0 0 40px rgba(100, 200, 255, 0.3);
        }

        button {
            background: linear-gradient(135deg, rgba(100, 150, 255, 0.4), rgba(150, 100, 255, 0.4));
            border: 2px solid rgba(100, 200, 255, 0.5);
            color: white;
            padding: 12px 24px;
            border-radius: 15px;
            cursor: pointer;
            margin: 6px 6px 6px 0;
            font-size: 13px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button:before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.3), transparent);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
            border-radius: 50%;
        }

        button:hover {
            transform: translateY(-3px);
            border-color: rgba(100, 200, 255, 0.9);
            box-shadow: 0 8px 25px rgba(100, 150, 255, 0.5),
                        0 0 30px rgba(100, 200, 255, 0.3);
            background: linear-gradient(135deg, rgba(120, 170, 255, 0.5), rgba(170, 120, 255, 0.5));
        }

        button:hover:before {
            width: 300px;
            height: 300px;
        }

        button:active {
            transform: translateY(-1px);
        }

        input[type="range"] {
            width: 100%;
            margin: 12px 0;
            -webkit-appearance: none;
            background: transparent;
            height: 6px;
        }

        input[type="range"]::-webkit-slider-track {
            width: 100%;
            height: 6px;
            background: linear-gradient(90deg, 
                rgba(100, 150, 255, 0.3), 
                rgba(150, 100, 255, 0.3));
            border-radius: 3px;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #6cf, #96f);
            cursor: pointer;
            box-shadow: 0 0 15px rgba(100, 200, 255, 0.9),
                        0 0 30px rgba(100, 200, 255, 0.5);
            transition: all 0.2s;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.3);
            box-shadow: 0 0 25px rgba(100, 200, 255, 1),
                        0 0 50px rgba(100, 200, 255, 0.7);
        }

        select, input[type="file"], input[type="text"], input[type="number"] {
            width: 100%;
            padding: 12px 16px;
            margin: 10px 0;
            background: rgba(20, 30, 60, 0.5);
            border: 2px solid rgba(100, 200, 255, 0.3);
            border-radius: 12px;
            color: #e0f0ff;
            font-family: 'Orbitron', sans-serif;
            font-size: 13px;
            transition: all 0.3s;
        }

        select:hover, select:focus,
        input[type="text"]:hover, input[type="text"]:focus,
        input[type="number"]:hover, input[type="number"]:focus {
            background: rgba(30, 40, 80, 0.6);
            border-color: rgba(100, 200, 255, 0.6);
            outline: none;
            box-shadow: 0 0 20px rgba(100, 150, 255, 0.3);
        }

        .stat-line {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            padding: 12px 16px;
            background: linear-gradient(90deg, 
                rgba(20, 40, 80, 0.3), 
                rgba(40, 20, 80, 0.2));
            border-radius: 10px;
            border-left: 4px solid rgba(100, 200, 255, 0.5);
            transition: all 0.3s;
        }

        .stat-line:hover {
            background: linear-gradient(90deg, 
                rgba(30, 50, 100, 0.4), 
                rgba(50, 30, 100, 0.3));
            border-left-color: rgba(100, 200, 255, 0.9);
            transform: translateX(8px);
            box-shadow: 0 4px 15px rgba(100, 150, 255, 0.2);
        }

        .stat-label {
            color: #6cf;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(100, 200, 255, 0.4);
        }

        .control-group {
            margin: 22px 0;
            padding: 20px;
            background: linear-gradient(135deg, 
                rgba(10, 20, 50, 0.3), 
                rgba(20, 10, 50, 0.2));
            border-radius: 15px;
            border: 1px solid rgba(100, 200, 255, 0.15);
            transition: all 0.3s;
        }

        .control-group:hover {
            background: linear-gradient(135deg, 
                rgba(15, 25, 60, 0.4), 
                rgba(25, 15, 60, 0.3));
            border-color: rgba(100, 200, 255, 0.25);
            box-shadow: 0 5px 20px rgba(100, 150, 255, 0.15);
        }

        .control-group strong {
            color: #8df;
            font-size: 14px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            text-shadow: 0 0 10px rgba(140, 220, 255, 0.4);
        }

        #spectrumCanvas {
            width: 100%;
            height: 120px;
            border-radius: 15px;
        }

        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(10, 20, 40, 0.3);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, 
                rgba(100, 150, 255, 0.6), 
                rgba(150, 100, 255, 0.6));
            border-radius: 10px;
            border: 2px solid rgba(10, 20, 40, 0.3);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, 
                rgba(120, 170, 255, 0.8), 
                rgba(170, 120, 255, 0.8));
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 1000;
        }

        .spinner {
            border: 5px solid rgba(100, 200, 255, 0.1);
            border-top: 5px solid #6cf;
            border-radius: 50%;
            width: 80px;
            height: 80px;
            animation: spin 1s linear infinite;
            margin: 25px auto;
            box-shadow: 0 0 40px rgba(100, 200, 255, 0.5);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .cosmic-title {
            font-size: 48px;
            font-weight: 900;
            background: linear-gradient(135deg, #6cf, #96f, #c6f, #6cf);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradientShift 4s ease infinite;
            letter-spacing: 4px;
            text-shadow: 0 0 50px rgba(100, 200, 255, 0.5);
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .hint {
            font-size: 11px;
            color: rgba(200, 220, 255, 0.5);
            margin-top: 8px;
            font-style: italic;
            font-weight: 300;
        }

        .planet-item {
            background: rgba(30, 50, 100, 0.3);
            padding: 15px;
            margin: 10px 0;
            border-radius: 10px;
            border-left: 3px solid;
            transition: all 0.3s;
        }

        .planet-item:hover {
            background: rgba(40, 60, 120, 0.4);
            transform: translateX(5px);
        }

        .overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 999;
            backdrop-filter: blur(5px);
        }

        .glow-value {
            color: #6cf;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(100, 200, 255, 0.6);
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="overlay" id="overlay"></div>
    
    <div id="loading">
        <div class="cosmic-title">STELLAR SYMPHONY</div>
        <div class="spinner"></div>
        <div>Generating Universe...</div>
    </div>

    <div id="controls" class="ui-panel">
        <h3>Control Center</h3>
        
        <div class="control-group">
            <strong>Audio Source</strong>
            <input type="file" id="audioFile" accept="audio/*">
            <button onclick="startMicrophone()">Microphone</button>
            <button onclick="generateAmbient()">Cosmic Ambient</button>
            <button onclick="toggleAudio()" id="audioBtn">Play</button>
        </div>

        <div class="control-group">
            <strong>Volume: <span id="volumeDisplay" class="glow-value">50</span>%</strong>
            <input type="range" id="volumeSlider" min="0" max="100" value="50" oninput="changeVolume(this.value)">
        </div>

        <div class="control-group">
            <strong>Time Flow: <span id="timeSpeed" class="glow-value">1.0</span>x</strong>
            <input type="range" id="timeSlider" min="-10" max="30" value="0" step="1" oninput="changeTimeSpeed(this.value)">
        </div>

        <div class="control-group">
            <strong>System Control</strong>
            <button onclick="generateNewSystem()">Generate New</button>
            <button onclick="openEditor()">Edit System</button>
            <button onclick="saveSystem()">Save System</button>
            <button onclick="loadSystem()">Load System</button>
        </div>

        <div class="control-group">
            <button onclick="screenshot()">Screenshot</button>
            <button onclick="toggleUI()">Toggle UI</button>
        </div>
    </div>

    <div id="info" class="ui-panel">
        <h3 id="objectName">Stellar System</h3>
        <div id="objectInfo">
            <p style="line-height: 1.8; color: rgba(200, 220, 255, 0.8); font-size: 13px;">
                A procedurally-generated stellar system with reactive audio visualization.
                The stars in the sky pulse with their frequency ranges.
                Click on objects to explore.
            </p>
        </div>
    </div>

    <div id="spectrum" class="ui-panel">
        <canvas id="spectrumCanvas"></canvas>
    </div>

    <div id="editor" class="ui-panel">
        <h3>System Editor</h3>
        
        <div class="control-group">
            <strong>Star Type</strong>
            <select id="starTypeSelect">
                <option value="O">O - Blue Hypergiant (30000K)</option>
                <option value="B">B - Blue-White (18000K)</option>
                <option value="A">A - White (8500K)</option>
                <option value="G" selected>G - Yellow (5800K)</option>
                <option value="K">K - Orange (4500K)</option>
                <option value="M">M - Red (3000K)</option>
            </select>
        </div>

        <div class="control-group">
            <strong>Number of Planets: <span id="planetCount" class="glow-value">5</span></strong>
            <input type="range" id="planetCountSlider" min="1" max="12" value="5" oninput="updatePlanetCount(this.value)">
        </div>

        <div id="planetsList"></div>

        <button onclick="applyChanges()">Apply Changes</button>
        <button onclick="closeEditor()">Cancel</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, audioContext, analyser, dataArray;
        let centralStar, planets = [], orbitLines = [];
        let backgroundStars = [];
        let timeScale = 1.0;
        let clock = new THREE.Clock();
        let audioSource = null, audioElement = null, gainNode = null;
        let mouseDown = false, mouseX = 0, mouseY = 0;
        let cameraRotation = {x: 0.3, y: 0};
        let cameraPosition = new THREE.Vector3(0, 80, 200);
        let cameraVelocity = new THREE.Vector3();
        let keys = {};
        let ambientOscillators = [];
        let currentSystem = null;

        const STAR_TYPES = {
            'O': {color: 0x9bb0ff, temp: 30000, size: 10, freq: [6000, 20000]},
            'B': {color: 0xaabfff, temp: 18000, size: 8, freq: [4000, 10000]},
            'A': {color: 0xcad7ff, temp: 8500, size: 6, freq: [2000, 6000]},
            'G': {color: 0xfff4ea, temp: 5800, size: 5, freq: [500, 2000]},
            'K': {color: 0xffd2a1, temp: 4500, size: 4, freq: [250, 500]},
            'M': {color: 0xffcc6f, temp: 3000, size: 3.5, freq: [60, 250]}
        };

        const PLANET_TYPES = [
            {type: 'Rocky', colors: [0x8b7355, 0x6b5345], size: [1, 2.5]},
            {type: 'Gas Giant', colors: [0xd4a574, 0xc49464], size: [3.5, 7]},
            {type: 'Ice Giant', colors: [0x4fc3f7, 0x3fb3e7], size: [3, 5]},
            {type: 'Lava World', colors: [0xff4500, 0xff6a00], size: [0.8, 2]},
            {type: 'Ocean', colors: [0x006994, 0x005984], size: [1.2, 3]}
        ];

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000208, 0.00005);
            
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 5000);
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('canvas'),
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            camera.position.copy(cameraPosition);

            const ambientLight = new THREE.AmbientLight(0x1a2344, 0.4);
            scene.add(ambientLight);

            createBackgroundStars();
            generateNewSystem();
            setupAudio();
            setupEvents();

            setTimeout(() => {
                document.getElementById('loading').style.opacity = '0';
                document.getElementById('loading').style.transition = 'opacity 1s';
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 1000);
            }, 1500);
            
            animate();
        }

        function createBackgroundStars() {
            for (let i = 0; i < 3000; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const radius = 1500 + Math.random() * 2000;
                
                const x = Math.sin(phi) * Math.cos(theta) * radius;
                const y = Math.sin(phi) * Math.sin(theta) * radius;
                const z = Math.cos(phi) * radius;

                const starTypes = Object.values(STAR_TYPES);
                const starType = starTypes[Math.floor(Math.random() * starTypes.length)];
                
                const geometry = new THREE.SphereGeometry(0.5 + Math.random() * 1, 8, 8);
                const material = new THREE.MeshBasicMaterial({
                    color: starType.color,
                    transparent: true,
                    opacity: 0.4 + Math.random() * 0.3
                });
                
                const star = new THREE.Mesh(geometry, material);
                star.position.set(x, y, z);
                scene.add(star);
                
                backgroundStars.push({
                    mesh: star,
                    baseOpacity: material.opacity,
                    freqRange: starType.freq,
                    material: material
                });
            }
        }

        function generateNewSystem() {
            if (centralStar) {
                scene.remove(centralStar.mesh);
                planets.forEach(p => {
                    scene.remove(p.mesh);
                    if (p.trail) scene.remove(p.trail);
                });
                orbitLines.forEach(l => scene.remove(l));
            }

            planets = [];
            orbitLines = [];

            const starTypeKey = 'G';
            const starType = STAR_TYPES[starTypeKey];
            
            createCentralStar(starType, starTypeKey);
            
            const numPlanets = 3 + Math.floor(Math.random() * 7);
            for (let i = 0; i < numPlanets; i++) {
                createPlanet(i);
            }

            currentSystem = {
                starType: starTypeKey,
                planets: planets.map(p => ({
                    type: p.planetType,
                    size: p.size,
                    orbitRadius: p.orbit.radius,
                    orbitSpeed: p.orbit.speed
                }))
            };

            updateSystemInfo();
        }

        function createCentralStar(starType, typeKey) {
            const starGeometry = new THREE.SphereGeometry(starType.size, 64, 64);
            const starMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    baseColor: { value: new THREE.Color(starType.color) },
                    intensity: { value: 1.0 }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    uniform float time;
                    
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vPosition = position;
                        vec3 pos = position;
                        float displacement = sin(pos.x * 0.5 + time) * 
                                           cos(pos.y * 0.5 + time) * 0.2;
                        pos += normal * displacement;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 baseColor;
                    uniform float intensity;
                    uniform float time;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    
                    void main() {
                        float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 1.8);
                        float pulse = sin(time * 1.5) * 0.1 + 0.9;
                        vec3 glow = baseColor * (intensity * pulse + fresnel * 0.6);
                        gl_FragColor = vec4(glow, 1.0);
                    }
                `
            });
            
            const starMesh = new THREE.Mesh(starGeometry, starMaterial);
            scene.add(starMesh);

            const glowGeometry = new THREE.SphereGeometry(starType.size * 2.5, 32, 32);
            const glowMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    color: { value: new THREE.Color(starType.color) }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;
                    uniform float time;
                    varying vec3 vNormal;
                    
                    void main() {
                        float intensity = pow(0.7 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.8);
                        float pulse = sin(time * 1.2) * 0.15 + 0.85;
                        gl_FragColor = vec4(color, intensity * 0.4 * pulse);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide,
                depthWrite: false
            });
            
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            starMesh.add(glow);

            const pointLight = new THREE.PointLight(starType.color, 2, 400);
            starMesh.add(pointLight);

            centralStar = {
                mesh: starMesh,
                type: starType,
                typeKey: typeKey,
                material: starMaterial,
                glowMaterial: glowMaterial
            };
        }

        function createPlanet(index) {
            const planetType = PLANET_TYPES[Math.floor(Math.random() * PLANET_TYPES.length)];
            const size = planetType.size[0] + Math.random() * (planetType.size[1] - planetType.size[0]);
            
            const planetGeometry = new THREE.SphereGeometry(size, 32, 32);
            const planetMaterial = new THREE.MeshStandardMaterial({
                color: planetType.colors[0],
                roughness: 0.8,
                metalness: 0.2,
                emissive: planetType.type === 'Lava World' ? planetType.colors[1] : 0x000000,
                emissiveIntensity: planetType.type === 'Lava World' ? 0.5 : 0
            });
            const planetMesh = new THREE.Mesh(planetGeometry, planetMaterial);

            const orbitRadius = 25 + index * 18 + Math.random() * 10;
            const orbitSpeed = 0.0015 / Math.sqrt(orbitRadius * 0.15);
            const orbitAngle = Math.random() * Math.PI * 2;
            
            planetMesh.position.x = Math.cos(orbitAngle) * orbitRadius;
            planetMesh.position.z = Math.sin(orbitAngle) * orbitRadius;
            planetMesh.position.y = 0;

            scene.add(planetMesh);

            // Orbit trail
            const trailPoints = [];
            const segments = 128;
            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                trailPoints.push(new THREE.Vector3(
                    Math.cos(angle) * orbitRadius,
                    0,
                    Math.sin(angle) * orbitRadius
                ));
            }
            
            const trailGeometry = new THREE.BufferGeometry().setFromPoints(trailPoints);
            const trailMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    color: { value: new THREE.Color(planetType.colors[0]) },
                    audioIntensity: { value: 0.0 }
                },
                vertexShader: `
                    varying float vProgress;
                    uniform float audioIntensity;
                    
                    void main() {
                        vProgress = position.x;
                        vec3 pos = position;
                        pos.y += sin(position.x * 0.1 + position.z * 0.1) * audioIntensity * 3.0;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;
                    uniform float audioIntensity;
                    varying float vProgress;
                    
                    void main() {
                        float alpha = 0.3 + audioIntensity * 0.4;
                        gl_FragColor = vec4(color, alpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            
            const trail = new THREE.Line(trailGeometry, trailMaterial);
            scene.add(trail);

            // Atmosphere
            if (planetType.type !== 'Rocky' && planetType.type !== 'Lava World') {
                const atmGeometry = new THREE.SphereGeometry(size * 1.15, 24, 24);
                const atmMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        color: { value: new THREE.Color(planetType.colors[0]) }
                    },
                    vertexShader: `
                        varying vec3 vNormal;
                        void main() {
                            vNormal = normalize(normalMatrix * normal);
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 color;
                        varying vec3 vNormal;
                        void main() {
                            float intensity = pow(0.5 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
                            gl_FragColor = vec4(color, intensity * 0.5);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    side: THREE.BackSide
                });
                const atmosphere = new THREE.Mesh(atmGeometry, atmMaterial);
                planetMesh.add(atmosphere);
            }

            planets.push({
                mesh: planetMesh,
                planetType: planetType.type,
                size: size,
                orbit: {radius: orbitRadius, speed: orbitSpeed, angle: orbitAngle},
                baseY: 0,
                trail: trail,
                trailMaterial: trailMaterial
            });
        }

        function setupAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;
            analyser.smoothingTimeConstant = 0.85;
            dataArray = new Uint8Array(analyser.frequencyBinCount);
            
            gainNode = audioContext.createGain();
            gainNode.gain.value = 0.5;
            gainNode.connect(audioContext.destination);

            document.getElementById('audioFile').addEventListener('change', function(e) {
                const file = e.target.files[0];
                if (file) {
                    if (audioElement) {
                        audioElement.pause();
                        audioElement = null;
                    }
                    
                    audioElement = new Audio();
                    audioElement.src = URL.createObjectURL(file);
                    audioElement.loop = true;
                    
                    if (audioSource) {
                        audioSource.disconnect();
                    }
                    
                    audioSource = audioContext.createMediaElementSource(audioElement);
                    audioSource.connect(analyser);
                    analyser.connect(gainNode);
                    
                    audioElement.play().then(() => {
                        document.getElementById('audioBtn').textContent = 'Pause';
                    });
                }
            });
        }

        function startMicrophone() {
            navigator.mediaDevices.getUserMedia({audio: true})
                .then(stream => {
                    if (audioElement) {
                        audioElement.pause();
                        audioElement = null;
                    }
                    if (audioSource) {
                        audioSource.disconnect();
                    }
                    
                    audioSource = audioContext.createMediaStreamSource(stream);
                    audioSource.connect(analyser);
                    analyser.connect(gainNode);
                    
                    document.getElementById('audioBtn').textContent = 'Stop';
                });
        }

        function generateAmbient() {
            if (audioElement) {
                audioElement.pause();
                audioElement = null;
            }
            
            ambientOscillators.forEach(osc => {
                if (osc.stop) osc.stop();
            });
            ambientOscillators = [];
            
            const filter = audioContext.createBiquadFilter();
            filter.type = 'lowpass';
            filter.frequency.value = 1500;
            filter.Q.value = 0.8;
            
            const reverb = audioContext.createConvolver();
            const reverbTime = 5;
            const sampleRate = audioContext.sampleRate;
            const length = sampleRate * reverbTime;
            const impulse = audioContext.createBuffer(2, length, sampleRate);
            
            for (let channel = 0; channel < 2; channel++) {
                const channelData = impulse.getChannelData(channel);
                for (let i = 0; i < length; i++) {
                    channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 3);
                }
            }
            reverb.buffer = impulse;
            
            const frequencies = [40, 60, 90, 120, 180, 240, 360];
            
            frequencies.forEach((freq, i) => {
                const osc = audioContext.createOscillator();
                const oscGain = audioContext.createGain();
                const lfo = audioContext.createOscillator();
                const lfoGain = audioContext.createGain();
                
                osc.type = ['sine', 'triangle', 'sawtooth'][i % 3];
                osc.frequency.value = freq;
                oscGain.gain.value = 0.2 / frequencies.length;
                
                lfo.type = 'sine';
                lfo.frequency.value = 0.03 + Math.random() * 0.12;
                lfoGain.gain.value = freq * 0.04;
                
                lfo.connect(lfoGain);
                lfoGain.connect(osc.frequency);
                
                osc.connect(oscGain);
                oscGain.connect(filter);
                
                lfo.start();
                osc.start();
                ambientOscillators.push(osc, lfo);
                
                setInterval(() => {
                    if (ambientOscillators.includes(osc)) {
                        const newFreq = freq * (0.9 + Math.random() * 0.2);
                        osc.frequency.exponentialRampToValueAtTime(newFreq, audioContext.currentTime + 8);
                    }
                }, 8000 + Math.random() * 5000);
            });
            
            filter.connect(reverb);
            reverb.connect(analyser);
            analyser.connect(gainNode);
            
            document.getElementById('audioBtn').textContent = 'Stop';
        }

        function toggleAudio() {
            if (audioElement) {
                if (audioElement.paused) {
                    audioElement.play();
                    document.getElementById('audioBtn').textContent = 'Pause';
                } else {
                    audioElement.pause();
                    document.getElementById('audioBtn').textContent = 'Play';
                }
            } else if (ambientOscillators.length > 0) {
                ambientOscillators.forEach(osc => osc.stop());
                ambientOscillators = [];
                document.getElementById('audioBtn').textContent = 'Play';
            }
        }

        function changeVolume(value) {
            const volume = parseFloat(value) / 100;
            if (gainNode) {
                gainNode.gain.value = volume;
            }
            document.getElementById('volumeDisplay').textContent = value;
        }

        function processAudio() {
            if (!analyser) return;
            
            analyser.getByteFrequencyData(dataArray);

            const bass = getAverageFrequency(0, 250) / 255;
            const mid = getAverageFrequency(250, 2000) / 255;
            const high = getAverageFrequency(2000, 20000) / 255;

            // Central star
            if (centralStar) {
                const freqValue = (bass * 0.4 + mid * 0.3 + high * 0.3);
                centralStar.material.uniforms.intensity.value = 0.85 + freqValue * 0.4;
                const targetScale = 1 + freqValue * 0.12;
                centralStar.mesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.1);
            }

            // Planets and trails
            planets.forEach(planet => {
                const targetY = planet.baseY + bass * 4;
                planet.mesh.position.y += (targetY - planet.mesh.position.y) * 0.08;
                planet.mesh.rotation.y += 0.005 * (1 + mid * 0.5);
                
                if (planet.trailMaterial) {
                    planet.trailMaterial.uniforms.audioIntensity.value = bass * 0.5 + mid * 0.3;
                }
            });

            // Background stars
            backgroundStars.forEach(star => {
                const freqValue = getFrequencyForRange(star.freqRange[0], star.freqRange[1]) / 255;
                const targetOpacity = star.baseOpacity + freqValue * 0.5;
                star.material.opacity += (targetOpacity - star.material.opacity) * 0.15;
            });

            drawSpectrum(dataArray);
        }

        function getAverageFrequency(startFreq, endFreq) {
            const nyquist = audioContext.sampleRate / 2;
            const startBin = Math.floor(startFreq / nyquist * dataArray.length);
            const endBin = Math.floor(endFreq / nyquist * dataArray.length);
            
            let sum = 0;
            for (let i = startBin; i < endBin; i++) {
                sum += dataArray[i];
            }
            return sum / (endBin - startBin);
        }

        function getFrequencyForRange(startFreq, endFreq) {
            return getAverageFrequency(startFreq, endFreq);
        }

        function drawSpectrum(dataArray) {
            const canvas = document.getElementById('spectrumCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, 'rgba(100, 200, 255, 0.02)');
            gradient.addColorStop(1, 'rgba(150, 100, 255, 0.02)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const barWidth = canvas.width / (dataArray.length / 2);
            
            for (let i = 0; i < dataArray.length / 2; i++) {
                const barHeight = (dataArray[i] / 255) * canvas.height * 0.9;
                const hue = 200 + (i / (dataArray.length / 2)) * 60;
                const gradient = ctx.createLinearGradient(0, canvas.height - barHeight, 0, canvas.height);
                gradient.addColorStop(0, `hsla(${hue}, 80%, 65%, 0.95)`);
                gradient.addColorStop(0.5, `hsla(${hue}, 80%, 50%, 0.7)`);
                gradient.addColorStop(1, `hsla(${hue}, 80%, 35%, 0.3)`);
                ctx.fillStyle = gradient;
                
                const x = i * barWidth;
                ctx.beginPath();
                ctx.moveTo(x, canvas.height);
                ctx.lineTo(x, canvas.height - barHeight);
                ctx.lineTo(x + barWidth - 1, canvas.height - barHeight);
                ctx.lineTo(x + barWidth - 1, canvas.height);
                ctx.closePath();
                ctx.fill();
                
                // Glow effect
                if (barHeight > canvas.height * 0.3) {
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = `hsla(${hue}, 80%, 60%, 0.8)`;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }
        }

        function setupEvents() {
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            const canvas = document.getElementById('canvas');
            canvas.addEventListener('mousedown', e => {
                mouseDown = true;
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            
            canvas.addEventListener('mousemove', e => {
                if (!mouseDown) return;
                
                const deltaX = e.clientX - mouseX;
                const deltaY = e.clientY - mouseY;
                
                cameraRotation.y -= deltaX * 0.004;
                cameraRotation.x -= deltaY * 0.004;
                cameraRotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraRotation.x));
                
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            
            canvas.addEventListener('mouseup', () => mouseDown = false);
            
            canvas.addEventListener('wheel', e => {
                e.preventDefault();
                const delta = e.deltaY * 0.001;
                cameraVelocity.z += delta * 5;
            });
            
            window.addEventListener('keydown', e => keys[e.key] = true);
            window.addEventListener('keyup', e => keys[e.key] = false);
        }

        function handleCameraMovement() {
            const speed = (keys['Shift'] ? 4 : 1.8) * timeScale;
            
            const forward = new THREE.Vector3(
                Math.sin(cameraRotation.y) * Math.cos(cameraRotation.x),
                Math.sin(cameraRotation.x),
                Math.cos(cameraRotation.y) * Math.cos(cameraRotation.x)
            );
            const right = new THREE.Vector3(
                Math.cos(cameraRotation.y),
                0,
                -Math.sin(cameraRotation.y)
            );

            if (keys['w'] || keys['W'] || keys['ArrowUp']) cameraVelocity.add(forward.multiplyScalar(speed * 0.4));
            if (keys['s'] || keys['S'] || keys['ArrowDown']) cameraVelocity.add(forward.multiplyScalar(-speed * 0.4));
            if (keys['a'] || keys['A'] || keys['ArrowLeft']) cameraVelocity.add(right.multiplyScalar(-speed * 0.4));
            if (keys['d'] || keys['D'] || keys['ArrowRight']) cameraVelocity.add(right.multiplyScalar(speed * 0.4));
            if (keys['q'] || keys['Q']) cameraVelocity.y += speed * 0.4;
            if (keys['e'] || keys['E']) cameraVelocity.y -= speed * 0.4;

            cameraVelocity.multiplyScalar(0.93);
            cameraPosition.add(cameraVelocity);

            camera.position.copy(cameraPosition);
            camera.rotation.order = 'YXZ';
            camera.rotation.y = cameraRotation.y;
            camera.rotation.x = cameraRotation.x;
        }

        function updateOrbits(delta) {
            planets.forEach(planet => {
                planet.orbit.angle += planet.orbit.speed * delta * timeScale;
                planet.mesh.position.x = Math.cos(planet.orbit.angle) * planet.orbit.radius;
                planet.mesh.position.z = Math.sin(planet.orbit.angle) * planet.orbit.radius;
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();
            
            if (centralStar) {
                centralStar.material.uniforms.time.value = time;
                centralStar.glowMaterial.uniforms.time.value = time;
            }
            
            processAudio();
            handleCameraMovement();
            updateOrbits(delta);
            
            renderer.render(scene, camera);
        }

        function changeTimeSpeed(value) {
            const v = parseFloat(value);
            timeScale = v < 0 ? Math.pow(10, v / 10) : Math.pow(10, v / 10);
            document.getElementById('timeSpeed').textContent = timeScale.toFixed(1);
        }

        function openEditor() {
            document.getElementById('editor').style.display = 'block';
            document.getElementById('overlay').style.display = 'block';
            
            document.getElementById('starTypeSelect').value = centralStar.typeKey;
            document.getElementById('planetCountSlider').value = planets.length;
            updatePlanetCount(planets.length);
        }

        function closeEditor() {
            document.getElementById('editor').style.display = 'none';
            document.getElementById('overlay').style.display = 'none';
        }

        function updatePlanetCount(count) {
            document.getElementById('planetCount').textContent = count;
        }

        function applyChanges() {
            const starTypeKey = document.getElementById('starTypeSelect').value;
            const planetCount = parseInt(document.getElementById('planetCountSlider').value);
            
            // Regenerate with new params
            if (centralStar) {
                scene.remove(centralStar.mesh);
                planets.forEach(p => {
                    scene.remove(p.mesh);
                    if (p.trail) scene.remove(p.trail);
                });
                planets = [];
            }

            createCentralStar(STAR_TYPES[starTypeKey], starTypeKey);
            
            for (let i = 0; i < planetCount; i++) {
                createPlanet(i);
            }

            updateSystemInfo();
            closeEditor();
        }

        function updateSystemInfo() {
            document.getElementById('objectInfo').innerHTML = `
                <div class="stat-line">
                    <span class="stat-label">Star Type:</span>
                    <span class="glow-value">${centralStar.typeKey}</span>
                </div>
                <div class="stat-line">
                    <span class="stat-label">Temperature:</span>
                    <span class="glow-value">${centralStar.type.temp.toLocaleString()} K</span>
                </div>
                <div class="stat-line">
                    <span class="stat-label">Planets:</span>
                    <span class="glow-value">${planets.length}</span>
                </div>
                <br>
                <p style="line-height: 1.8; color: rgba(200, 220, 255, 0.8); font-size: 13px;">
                    ${centralStar.typeKey}-class star with ${planets.length} orbiting planets.
                    Orbital trails react to audio frequencies.
                </p>
            `;
        }

        function saveSystem() {
            const systemData = {
                starType: centralStar.typeKey,
                planets: planets.map(p => ({
                    type: p.planetType,
                    size: p.size,
                    orbitRadius: p.orbit.radius,
                    orbitSpeed: p.orbit.speed
                }))
            };
            
            const dataStr = JSON.stringify(systemData, null, 2);
            const blob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = `stellar_system_${Date.now()}.json`;
            link.href = url;
            link.click();
        }

        function loadSystem() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'application/json';
            input.onchange = e => {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = event => {
                    try {
                        const systemData = JSON.parse(event.target.result);
                        // Implement loading logic here
                        alert('System loaded!');
                    } catch (err) {
                        alert('Failed to load system');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        function screenshot() {
            renderer.render(scene, camera);
            const link = document.createElement('a');
            link.download = `stellar_symphony_${Date.now()}.png`;
            link.href = renderer.domElement.toDataURL('image/png');
            link.click();
        }

        function toggleUI() {
            document.querySelectorAll('.ui-panel').forEach(panel => {
                if (panel.id !== 'editor') {
                    panel.style.display = panel.style.display === 'none' ? 'block' : 'none';
                }
            });
        }

        window.addEventListener('load', init);
    </script>
</body>
</html>
