<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stellar Symphony</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@300;400;700;900&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Orbitron', sans-serif;
            overflow: hidden;
            background: #000;
            color: #fff;
        }

        #canvas {
            display: block;
            width: 100%;
            height: 100vh;
        }

        .ui-panel {
            position: absolute;
            background: linear-gradient(135deg, rgba(10, 15, 35, 0.7), rgba(15, 25, 50, 0.5));
            backdrop-filter: blur(30px) saturate(200%);
            border: 1px solid rgba(100, 200, 255, 0.15);
            border-radius: 20px;
            padding: 25px;
            color: #e0f0ff;
            font-size: 13px;
            box-shadow: 0 15px 50px rgba(0, 100, 255, 0.15),
                        inset 0 2px 0 rgba(255, 255, 255, 0.1),
                        0 0 80px rgba(100, 150, 255, 0.05);
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .ui-panel:hover {
            background: linear-gradient(135deg, rgba(15, 25, 50, 0.8), rgba(20, 35, 65, 0.6));
            border-color: rgba(100, 200, 255, 0.3);
            box-shadow: 0 20px 60px rgba(0, 150, 255, 0.25),
                        inset 0 2px 0 rgba(255, 255, 255, 0.15),
                        0 0 100px rgba(100, 150, 255, 0.1);
        }

        #controls {
            top: 30px;
            left: 30px;
            width: 380px;
            max-height: 90vh;
            overflow-y: auto;
        }

        #info {
            top: 30px;
            right: 30px;
            width: 400px;
            max-height: 90vh;
            overflow-y: auto;
        }

        #spectrum {
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            width: 700px;
            height: 200px;
            padding: 20px;
        }

        #editor {
            display: none;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 500px;
            max-height: 80vh;
            overflow-y: auto;
            z-index: 1000;
        }

        h3 {
            margin: 0 0 20px 0;
            color: #6cf;
            font-size: 20px;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 3px;
            border-bottom: 3px solid;
            border-image: linear-gradient(90deg, #6cf, #96f, transparent) 1;
            padding-bottom: 12px;
            text-shadow: 0 0 20px rgba(100, 200, 255, 0.6),
                         0 0 40px rgba(100, 200, 255, 0.3);
        }

        button {
            background: linear-gradient(135deg, rgba(100, 150, 255, 0.4), rgba(150, 100, 255, 0.4));
            border: 2px solid rgba(100, 200, 255, 0.5);
            color: white;
            padding: 12px 24px;
            border-radius: 15px;
            cursor: pointer;
            margin: 6px 6px 6px 0;
            font-size: 13px;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        button:before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            background: radial-gradient(circle, rgba(255, 255, 255, 0.3), transparent);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
            border-radius: 50%;
        }

        button:hover {
            transform: translateY(-3px);
            border-color: rgba(100, 200, 255, 0.9);
            box-shadow: 0 8px 25px rgba(100, 150, 255, 0.5),
                        0 0 30px rgba(100, 200, 255, 0.3);
            background: linear-gradient(135deg, rgba(120, 170, 255, 0.5), rgba(170, 120, 255, 0.5));
        }

        button:hover:before {
            width: 300px;
            height: 300px;
        }

        button:active {
            transform: translateY(-1px);
        }

        input[type="range"] {
            width: 100%;
            margin: 12px 0;
            -webkit-appearance: none;
            appearance: none;
            background: transparent;
            height: 6px;
        }

        input[type="range"]::-webkit-slider-track {
            width: 100%;
            height: 6px;
            background: linear-gradient(90deg, 
                rgba(100, 150, 255, 0.3), 
                rgba(150, 100, 255, 0.3));
            border-radius: 3px;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.3);
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            height: 20px;
            width: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #6cf, #96f);
            cursor: pointer;
            box-shadow: 0 0 15px rgba(100, 200, 255, 0.9),
                        0 0 30px rgba(100, 200, 255, 0.5);
            transition: all 0.2s;
            border: 2px solid rgba(255, 255, 255, 0.3);
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.3);
            box-shadow: 0 0 25px rgba(100, 200, 255, 1),
                        0 0 50px rgba(100, 200, 255, 0.7);
        }

        select, input[type="file"], input[type="text"], input[type="number"] {
            width: 100%;
            padding: 12px 16px;
            margin: 10px 0;
            background: rgba(20, 30, 60, 0.5);
            border: 2px solid rgba(100, 200, 255, 0.3);
            border-radius: 12px;
            color: #e0f0ff;
            font-family: 'Orbitron', sans-serif;
            font-size: 13px;
            transition: all 0.3s;
        }

        select:hover, select:focus,
        input[type="text"]:hover, input[type="text"]:focus,
        input[type="number"]:hover, input[type="number"]:focus {
            background: rgba(30, 40, 80, 0.6);
            border-color: rgba(100, 200, 255, 0.6);
            outline: none;
            box-shadow: 0 0 20px rgba(100, 150, 255, 0.3);
        }

        .stat-line {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            padding: 12px 16px;
            background: linear-gradient(90deg, 
                rgba(20, 40, 80, 0.3), 
                rgba(40, 20, 80, 0.2));
            border-radius: 10px;
            border-left: 4px solid rgba(100, 200, 255, 0.5);
            transition: all 0.3s;
        }

        .stat-line:hover {
            background: linear-gradient(90deg, 
                rgba(30, 50, 100, 0.4), 
                rgba(50, 30, 100, 0.3));
            border-left-color: rgba(100, 200, 255, 0.9);
            transform: translateX(8px);
            box-shadow: 0 4px 15px rgba(100, 150, 255, 0.2);
        }

        .stat-label {
            color: #6cf;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(100, 200, 255, 0.4);
        }

        .control-group {
            margin: 22px 0;
            padding: 20px;
            background: linear-gradient(135deg, 
                rgba(10, 20, 50, 0.3), 
                rgba(20, 10, 50, 0.2));
            border-radius: 15px;
            border: 1px solid rgba(100, 200, 255, 0.15);
            transition: all 0.3s;
        }

        .control-group:hover {
            background: linear-gradient(135deg, 
                rgba(15, 25, 60, 0.4), 
                rgba(25, 15, 60, 0.3));
            border-color: rgba(100, 200, 255, 0.25);
            box-shadow: 0 5px 20px rgba(100, 150, 255, 0.15);
        }

        .control-group strong {
            color: #8df;
            font-size: 14px;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1.5px;
            text-shadow: 0 0 10px rgba(140, 220, 255, 0.4);
        }

        #spectrumCanvas {
            width: 100%;
            height: 110px;
            border-radius: 15px;
        }

        ::-webkit-scrollbar {
            width: 10px;
        }

        ::-webkit-scrollbar-track {
            background: rgba(10, 20, 40, 0.3);
            border-radius: 10px;
        }

        ::-webkit-scrollbar-thumb {
            background: linear-gradient(180deg, 
                rgba(100, 150, 255, 0.6), 
                rgba(150, 100, 255, 0.6));
            border-radius: 10px;
            border: 2px solid rgba(10, 20, 40, 0.3);
        }

        ::-webkit-scrollbar-thumb:hover {
            background: linear-gradient(180deg, 
                rgba(120, 170, 255, 0.8), 
                rgba(170, 120, 255, 0.8));
        }

        #loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            text-align: center;
            z-index: 1000;
        }

        .spinner {
            border: 5px solid rgba(100, 200, 255, 0.1);
            border-top: 5px solid #6cf;
            border-radius: 50%;
            width: 80px;
            height: 80px;
            animation: spin 1s linear infinite;
            margin: 25px auto;
            box-shadow: 0 0 40px rgba(100, 200, 255, 0.5);
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .cosmic-title {
            font-size: 48px;
            font-weight: 900;
            background: linear-gradient(135deg, #6cf, #96f, #c6f, #6cf);
            background-size: 300% 300%;
            -webkit-background-clip: text;
            background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: gradientShift 4s ease infinite;
            letter-spacing: 4px;
            text-shadow: 0 0 50px rgba(100, 200, 255, 0.5);
        }

        @keyframes gradientShift {
            0%, 100% { background-position: 0% 50%; }
            50% { background-position: 100% 50%; }
        }

        .hint {
            font-size: 11px;
            color: rgba(200, 220, 255, 0.5);
            margin-top: 8px;
            font-style: italic;
            font-weight: 300;
        }

        .planet-item {
            background: rgba(30, 50, 100, 0.3);
            padding: 15px;
            margin: 10px 0;
            border-radius: 10px;
            border-left: 3px solid;
            transition: all 0.3s;
        }

        .planet-item:hover {
            background: rgba(40, 60, 120, 0.4);
            transform: translateX(5px);
        }

        .overlay {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 999;
            backdrop-filter: blur(5px);
        }

        .glow-value {
            color: #6cf;
            font-weight: 700;
            text-shadow: 0 0 10px rgba(100, 200, 255, 0.6);
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="overlay" id="overlay"></div>
    
    <div id="loading">
        <div class="cosmic-title">STELLAR SYMPHONY</div>
        <div class="spinner"></div>
        <div>Generating Universe...</div>
    </div>

    <div id="controls" class="ui-panel">
        <h3>Control Center</h3>
        
        <div class="control-group">
            <strong>Audio Source</strong>
            <button onclick="initAudio()" id="initBtn" style="width: 100%; background: linear-gradient(135deg, rgba(255, 150, 100, 0.4), rgba(255, 100, 150, 0.4));">Enable Audio</button>
            <input type="file" id="audioFile" accept="audio/*" style="display: none;">
            <button onclick="document.getElementById('audioFile').click()" style="display: none;" id="loadFileBtn">Load Audio File</button>
            <button onclick="startMicrophone()" style="display: none;" id="micBtn">Microphone</button>
            <button onclick="generateAmbient()" style="display: none;" id="ambientBtn">Cosmic Ambient</button>
            <button onclick="toggleAudio()" id="audioBtn" style="display: none;">Play</button>
        </div>

        <div class="control-group">
            <strong>Volume: <span id="volumeDisplay" class="glow-value">50</span>%</strong>
            <input type="range" id="volumeSlider" min="0" max="100" value="50" oninput="changeVolume(this.value)">
        </div>

        <div class="control-group">
            <strong>Time Flow: <span id="timeSpeed" class="glow-value">1.0</span>x</strong>
            <input type="range" id="timeSlider" min="-10" max="30" value="0" step="1" oninput="changeTimeSpeed(this.value)">
        </div>

        <div class="control-group">
            <strong>System Control</strong>
            <button onclick="generateNewSystem()">Generate New</button>
            <button onclick="openEditor()">Edit System</button>
            <button onclick="saveSystem()">Save System</button>
            <button onclick="loadSystem()">Load System</button>
        </div>

        <div class="control-group">
            <button onclick="screenshot()">Screenshot</button>
            <button onclick="toggleUI()">Toggle UI</button>
        </div>
    </div>

    <div id="info" class="ui-panel">
        <h3 id="objectName">Stellar System</h3>
        <div id="objectInfo">
            <p style="line-height: 1.8; color: rgba(200, 220, 255, 0.8); font-size: 13px;">
                A procedurally-generated stellar system with reactive audio visualization.
                Orbital trails visualize sound like a waveform analyzer.
                Background stars pulse with their frequency ranges.
                Explore galaxy arms, star clusters, and nebulae.
            </p>
            <br>
            <div class="stat-line">
                <span class="stat-label">Hide/Show UI</span>
                <span>ESC</span>
            </div>
        </div>
    </div>

    <div id="spectrum" class="ui-panel">
        <div style="margin-bottom: 10px;">
            <strong style="color: #8df; font-size: 13px; text-transform: uppercase; letter-spacing: 1.5px;">Audio Timeline</strong>
            <div style="display: flex; align-items: center; gap: 10px; margin-top: 8px;">
                <span id="currentTime" style="font-size: 11px; color: rgba(200, 220, 255, 0.7);">0:00</span>
                <input type="range" id="seekSlider" min="0" max="100" value="0" step="0.1" style="flex: 1;" oninput="seekAudio(this.value)">
                <span id="totalTime" style="font-size: 11px; color: rgba(200, 220, 255, 0.7);">0:00</span>
            </div>
        </div>
        <canvas id="spectrumCanvas"></canvas>
    </div>

    <div id="editor" class="ui-panel">
        <h3>System Editor</h3>
        
        <div class="control-group">
            <strong>Star Type</strong>
            <select id="starTypeSelect">
                <option value="O">O - Blue Hypergiant (30000K)</option>
                <option value="B">B - Blue-White (18000K)</option>
                <option value="A">A - White (8500K)</option>
                <option value="G" selected>G - Yellow (5800K)</option>
                <option value="K">K - Orange (4500K)</option>
                <option value="M">M - Red (3000K)</option>
            </select>
        </div>

        <div class="control-group">
            <strong>Number of Planets: <span id="planetCount" class="glow-value">5</span></strong>
            <input type="range" id="planetCountSlider" min="1" max="12" value="5" oninput="updatePlanetCount(this.value)">
        </div>

        <div id="planetsList"></div>

        <button onclick="applyChanges()">Apply Changes</button>
        <button onclick="closeEditor()">Cancel</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, audioContext, analyser, dataArray;
        let centralStar, planets = [], orbitLines = [];
        let backgroundStars = [];
        let nebulae = [];
        let timeScale = 1.0;
        let clock = new THREE.Clock();
        let audioSource = null, audioElement = null, gainNode = null;
        let mouseDown = false, mouseX = 0, mouseY = 0;
        let cameraRotation = {x: 0.3, y: 0};
        let cameraPosition = new THREE.Vector3(0, 80, 200);
        let cameraVelocity = new THREE.Vector3();
        let keys = {};
        let ambientOscillators = [];
        let currentSystem = null;
        let uiVisible = true;

        const STAR_TYPES = {
            'O': {color: 0x9bb0ff, temp: 30000, size: 10, freq: [6000, 20000]},
            'B': {color: 0xaabfff, temp: 18000, size: 8, freq: [4000, 10000]},
            'A': {color: 0xcad7ff, temp: 8500, size: 6, freq: [2000, 6000]},
            'G': {color: 0xfff4ea, temp: 5800, size: 5, freq: [500, 2000]},
            'K': {color: 0xffd2a1, temp: 4500, size: 4, freq: [250, 500]},
            'M': {color: 0xffcc6f, temp: 3000, size: 3.5, freq: [60, 250]}
        };

        const PLANET_TYPES = [
            {type: 'Rocky Desert', colors: [0x8b7355, 0x6b5345], size: [1, 2.5], hasAtmosphere: false, roughness: 0.9},
            {type: 'Gas Giant', colors: [0xd4a574, 0xc49464], size: [3.5, 7], hasAtmosphere: true, roughness: 0.6},
            {type: 'Ice Giant', colors: [0x4fc3f7, 0x3fb3e7], size: [3, 5], hasAtmosphere: true, roughness: 0.5},
            {type: 'Lava World', colors: [0xff4500, 0xff6a00], size: [0.8, 2], hasAtmosphere: false, roughness: 0.7},
            {type: 'Ocean World', colors: [0x006994, 0x005984], size: [1.2, 3], hasAtmosphere: true, roughness: 0.3},
            {type: 'Ice World', colors: [0xb0e0e6, 0x87ceeb], size: [0.9, 2.2], hasAtmosphere: false, roughness: 0.2},
            {type: 'Volcanic', colors: [0x8b4513, 0xa0522d], size: [1.1, 2.4], hasAtmosphere: true, roughness: 0.8},
            {type: 'Earth-like', colors: [0x4a7c59, 0x2e5c47], size: [1, 2], hasAtmosphere: true, roughness: 0.7},
            {type: 'Gas Dwarf', colors: [0xffa07a, 0xff8c69], size: [2, 3.5], hasAtmosphere: true, roughness: 0.5},
            {type: 'Crystalline', colors: [0x9370db, 0x8a2be2], size: [0.7, 1.8], hasAtmosphere: false, roughness: 0.1}
        ];

        function init() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000208, 0.00005);
            
            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 5000);
            renderer = new THREE.WebGLRenderer({
                canvas: document.getElementById('canvas'),
                antialias: true,
                alpha: true
            });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            
            camera.position.copy(cameraPosition);

            const ambientLight = new THREE.AmbientLight(0x1a2344, 0.4);
            scene.add(ambientLight);

            // Initialize arrays
            backgroundStars = [];
            nebulae = [];
            
            createBackgroundStars();
            generateNewSystem();
            setupAudio();
            setupEvents();

            // Hide UI by default

            setTimeout(() => {
                document.getElementById('loading').style.opacity = '0';
                document.getElementById('loading').style.transition = 'opacity 1s';
                setTimeout(() => {
                    document.getElementById('loading').style.display = 'none';
                }, 1000);
            }, 1500);
            
            animate();
        }

        function createBackgroundStars() {
            // Distant stars - very far away (optimized)
            for (let i = 0; i < 3000; i++) {
                const theta = Math.random() * Math.PI * 2;
                const phi = Math.random() * Math.PI;
                const radius = 3500 + Math.random() * 3500;
                
                const x = Math.sin(phi) * Math.cos(theta) * radius;
                const y = Math.sin(phi) * Math.sin(theta) * radius;
                const z = Math.cos(phi) * radius;

                const starTypes = Object.values(STAR_TYPES);
                const starType = starTypes[Math.floor(Math.random() * starTypes.length)];
                
                const size = 0.4 + Math.random() * 1;
                const geometry = new THREE.SphereGeometry(size, 6, 6);
                const material = new THREE.MeshBasicMaterial({
                    color: starType.color,
                    transparent: true,
                    opacity: 0.25 + Math.random() * 0.25
                });
                
                const star = new THREE.Mesh(geometry, material);
                star.position.set(x, y, z);
                scene.add(star);
                
                const glowGeometry = new THREE.SphereGeometry(size * 2.5, 6, 6);
                const glowMaterial = new THREE.MeshBasicMaterial({
                    color: starType.color,
                    transparent: true,
                    opacity: 0.06,
                    blending: THREE.AdditiveBlending
                });
                const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                star.add(glow);
                
                backgroundStars.push({
                    mesh: star,
                    glow: glow,
                    baseOpacity: material.opacity,
                    baseGlowOpacity: 0.06,
                    freqRange: starType.freq,
                    material: material,
                    glowMaterial: glowMaterial
                });
            }
            
            // Create galaxy arms - closer and more realistic
            const numArms = 4;
            const starsPerArm = 180;
            
            for (let arm = 0; arm < numArms; arm++) {
                const armAngle = (arm / numArms) * Math.PI * 2;
                
                for (let i = 0; i < starsPerArm; i++) {
                    const distance = 1400 + Math.random() * 1600;
                    const armProgress = i / starsPerArm;
                    const angle = armAngle + armProgress * Math.PI * 3 + (Math.random() - 0.5) * 0.6;
                    
                    const x = Math.cos(angle) * distance + (Math.random() - 0.5) * 150;
                    const y = (Math.random() - 0.5) * 300 * (1 - armProgress * 0.5);
                    const z = Math.sin(angle) * distance + (Math.random() - 0.5) * 150;

                    const starTypes = Object.values(STAR_TYPES);
                    const starType = starTypes[Math.floor(Math.random() * starTypes.length)];
                    
                    const size = 1 + Math.random() * 2.5;
                    const geometry = new THREE.SphereGeometry(size, 16, 16);
                    const material = new THREE.MeshBasicMaterial({
                        color: starType.color,
                        transparent: true,
                        opacity: 0.6 + Math.random() * 0.3
                    });
                    
                    const star = new THREE.Mesh(geometry, material);
                    star.position.set(x, y, z);
                    scene.add(star);
                    
                    const glowGeometry = new THREE.SphereGeometry(size * 3, 16, 16);
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: starType.color,
                        transparent: true,
                        opacity: 0.2,
                        blending: THREE.AdditiveBlending
                    });
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    star.add(glow);
                    
                    backgroundStars.push({
                        mesh: star,
                        glow: glow,
                        baseOpacity: material.opacity,
                        baseGlowOpacity: 0.2,
                        freqRange: starType.freq,
                        material: material,
                        glowMaterial: glowMaterial
                    });
                }
            }
            
            // Create star clusters
            const numClusters = 8;
            for (let c = 0; c < numClusters; c++) {
                const clusterX = (Math.random() - 0.5) * 3000;
                const clusterY = (Math.random() - 0.5) * 700;
                const clusterZ = (Math.random() - 0.5) * 3000;
                const clusterSize = 90 + Math.random() * 110;
                const starsInCluster = 25 + Math.floor(Math.random() * 30);
                
                for (let i = 0; i < starsInCluster; i++) {
                    const theta = Math.random() * Math.PI * 2;
                    const phi = Math.random() * Math.PI;
                    const r = Math.random() * clusterSize;
                    
                    const x = clusterX + Math.sin(phi) * Math.cos(theta) * r;
                    const y = clusterY + Math.sin(phi) * Math.sin(theta) * r;
                    const z = clusterZ + Math.cos(phi) * r;

                    const starTypes = Object.values(STAR_TYPES);
                    const starType = starTypes[Math.floor(Math.random() * 3)];
                    
                    const size = 0.8 + Math.random() * 1.8;
                    const geometry = new THREE.SphereGeometry(size, 12, 12);
                    const material = new THREE.MeshBasicMaterial({
                        color: starType.color,
                        transparent: true,
                        opacity: 0.6 + Math.random() * 0.3
                    });
                    
                    const star = new THREE.Mesh(geometry, material);
                    star.position.set(x, y, z);
                    scene.add(star);
                    
                    const glowGeometry = new THREE.SphereGeometry(size * 2.2, 12, 12);
                    const glowMaterial = new THREE.MeshBasicMaterial({
                        color: starType.color,
                        transparent: true,
                        opacity: 0.18,
                        blending: THREE.AdditiveBlending
                    });
                    const glow = new THREE.Mesh(glowGeometry, glowMaterial);
                    star.add(glow);
                    
                    backgroundStars.push({
                        mesh: star,
                        glow: glow,
                        baseOpacity: material.opacity,
                        baseGlowOpacity: 0.18,
                        freqRange: starType.freq,
                        material: material,
                        glowMaterial: glowMaterial
                    });
                }
            }
            
            // Create nebulae
            const numNebulae = 5;
            for (let n = 0; n < numNebulae; n++) {
                const nebulaColors = [
                    [0x1a4d7a, 0x7a1a4d],
                    [0x2d1a5a, 0x1a5a2d],
                    [0x5a2d1a, 0x1a2d5a],
                    [0x4d1a7a, 0x1a7a4d]
                ];
                const colors = nebulaColors[Math.floor(Math.random() * nebulaColors.length)];
                
                const size = 280 + Math.random() * 320;
                const x = (Math.random() - 0.5) * 2600;
                const y = (Math.random() - 0.5) * 650;
                const z = (Math.random() - 0.5) * 2600;
                
                const geometry = new THREE.SphereGeometry(size, 24, 24);
                const material = new THREE.ShaderMaterial({
                    uniforms: {
                        time: { value: 0 },
                        color1: { value: new THREE.Color(colors[0]) },
                        color2: { value: new THREE.Color(colors[1]) },
                        audioIntensity: { value: 0.0 }
                    },
                    vertexShader: `
                        varying vec3 vPosition;
                        varying vec3 vNormal;
                        void main() {
                            vPosition = position;
                            vNormal = normalize(normalMatrix * normal);
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform float time;
                        uniform vec3 color1;
                        uniform vec3 color2;
                        uniform float audioIntensity;
                        varying vec3 vPosition;
                        varying vec3 vNormal;
                        
                        float noise(vec3 p) {
                            return sin(p.x * 0.02 + time * 0.1) * 
                                   cos(p.y * 0.02 + time * 0.15) * 
                                   sin(p.z * 0.02 + time * 0.12);
                        }
                        
                        void main() {
                            float n = noise(vPosition);
                            float n2 = noise(vPosition * 2.0 + vec3(100.0));
                            vec3 color = mix(color1, color2, n * 0.5 + 0.5);
                            float edge = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 2.0);
                            float alpha = (0.06 + abs(n) * 0.08 + n2 * 0.04 + audioIntensity * 0.1) * edge;
                            gl_FragColor = vec4(color, alpha);
                        }
                    `,
                    transparent: true,
                    side: THREE.DoubleSide,
                    blending: THREE.AdditiveBlending,
                    depthWrite: false
                });
                
                const nebula = new THREE.Mesh(geometry, material);
                nebula.position.set(x, y, z);
                scene.add(nebula);
                nebulae.push(nebula);
            }
        }

        function generateNewSystem() {
            if (centralStar) {
                scene.remove(centralStar.mesh);
                planets.forEach(p => {
                    scene.remove(p.mesh);
                    if (p.trail) scene.remove(p.trail);
                });
                orbitLines.forEach(l => scene.remove(l));
            }

            planets = [];
            orbitLines = [];

            const starTypeKey = 'G';
            const starType = STAR_TYPES[starTypeKey];
            
            createCentralStar(starType, starTypeKey);
            
            const numPlanets = 3 + Math.floor(Math.random() * 7);
            for (let i = 0; i < numPlanets; i++) {
                createPlanet(i);
            }

            currentSystem = {
                starType: starTypeKey,
                planets: planets.map(p => ({
                    type: p.planetType,
                    size: p.size,
                    orbitRadius: p.orbit.radius,
                    orbitSpeed: p.orbit.speed
                }))
            };

            updateSystemInfo();
        }

        function createCentralStar(starType, typeKey) {
            const starGeometry = new THREE.SphereGeometry(starType.size, 64, 64);
            const starMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    baseColor: { value: new THREE.Color(starType.color) },
                    intensity: { value: 1.0 }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    uniform float time;
                    
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        vPosition = position;
                        vec3 pos = position;
                        float displacement = sin(pos.x * 0.5 + time) * 
                                           cos(pos.y * 0.5 + time) * 0.2;
                        pos += normal * displacement;
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 baseColor;
                    uniform float intensity;
                    uniform float time;
                    varying vec3 vNormal;
                    varying vec3 vPosition;
                    
                    void main() {
                        float fresnel = pow(1.0 - abs(dot(vNormal, vec3(0.0, 0.0, 1.0))), 1.8);
                        float pulse = sin(time * 1.5) * 0.1 + 0.9;
                        vec3 glow = baseColor * (intensity * pulse + fresnel * 0.6);
                        gl_FragColor = vec4(glow, 1.0);
                    }
                `
            });
            
            const starMesh = new THREE.Mesh(starGeometry, starMaterial);
            scene.add(starMesh);

            const glowGeometry = new THREE.SphereGeometry(starType.size * 2.5, 32, 32);
            const glowMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    color: { value: new THREE.Color(starType.color) }
                },
                vertexShader: `
                    varying vec3 vNormal;
                    void main() {
                        vNormal = normalize(normalMatrix * normal);
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;
                    uniform float time;
                    varying vec3 vNormal;
                    
                    void main() {
                        float intensity = pow(0.7 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.8);
                        float pulse = sin(time * 1.2) * 0.15 + 0.85;
                        gl_FragColor = vec4(color, intensity * 0.4 * pulse);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending,
                side: THREE.BackSide,
                depthWrite: false
            });
            
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            starMesh.add(glow);

            const pointLight = new THREE.PointLight(starType.color, 2, 400);
            starMesh.add(pointLight);

            centralStar = {
                mesh: starMesh,
                type: starType,
                typeKey: typeKey,
                material: starMaterial,
                glowMaterial: glowMaterial
            };
        }

        function createPlanet(index) {
            const planetType = PLANET_TYPES[Math.floor(Math.random() * PLANET_TYPES.length)];
            const size = planetType.size[0] + Math.random() * (planetType.size[1] - planetType.size[0]);
            
            const planetGeometry = new THREE.SphereGeometry(size, 32, 32);
            const planetMaterial = new THREE.MeshStandardMaterial({
                color: planetType.colors[0],
                roughness: 0.8,
                metalness: 0.2,
                emissive: planetType.type === 'Lava World' ? planetType.colors[1] : 0x000000,
                emissiveIntensity: planetType.type === 'Lava World' ? 0.5 : 0
            });
            const planetMesh = new THREE.Mesh(planetGeometry, planetMaterial);

            const orbitRadius = 25 + index * 18 + Math.random() * 10;
            const orbitSpeed = 0.0015 / Math.sqrt(orbitRadius * 0.15);
            const orbitAngle = Math.random() * Math.PI * 2;
            
            planetMesh.position.x = Math.cos(orbitAngle) * orbitRadius;
            planetMesh.position.z = Math.sin(orbitAngle) * orbitRadius;
            planetMesh.position.y = 0;

            scene.add(planetMesh);

            // Orbit trail - visual audio wave
            const trailPoints = [];
            const segments = 512;
            const indices = [];
            
            for (let i = 0; i <= segments; i++) {
                const angle = (i / segments) * Math.PI * 2;
                trailPoints.push(new THREE.Vector3(
                    Math.cos(angle) * orbitRadius,
                    0,
                    Math.sin(angle) * orbitRadius
                ));
            }
            
            const trailGeometry = new THREE.BufferGeometry().setFromPoints(trailPoints);
            
            // Add vertex index attribute
            const vertexIndices = new Float32Array(segments + 1);
            for (let i = 0; i <= segments; i++) {
                vertexIndices[i] = i;
            }
            trailGeometry.setAttribute('vertexIndex', new THREE.BufferAttribute(vertexIndices, 1));
            
            const trailMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    color: { value: new THREE.Color(planetType.colors[0]) },
                    audioData: { value: new Float32Array(128) },
                    time: { value: 0 },
                    audioIntensity: { value: 0.0 },
                    totalSegments: { value: segments }
                },
                vertexShader: `
                    attribute float vertexIndex;
                    uniform float audioData[128];
                    uniform float time;
                    uniform float audioIntensity;
                    uniform float totalSegments;
                    varying float vIntensity;
                    varying float vProgress;
                    
                    void main() {
                        vec3 pos = position;
                        
                        float normalizedIndex = vertexIndex / totalSegments;
                        vProgress = normalizedIndex;
                        
                        // Get audio data for this segment
                        int audioIndex = int(normalizedIndex * 127.0);
                        float audioValue = audioData[audioIndex];
                        
                        // Create smooth wave effect based on audio
                        float wave = audioValue * 12.0;
                        
                        // Add smooth sine waves for fluid motion
                        wave += sin(normalizedIndex * 25.0 + time * 3.0) * audioIntensity * 2.5;
                        wave += cos(normalizedIndex * 18.0 - time * 2.0) * audioIntensity * 1.8;
                        
                        pos.y += wave;
                        
                        vIntensity = audioValue;
                        
                        gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
                    }
                `,
                fragmentShader: `
                    uniform vec3 color;
                    uniform float audioIntensity;
                    varying float vIntensity;
                    varying float vProgress;
                    
                    void main() {
                        // Smooth gradient along the trail
                        float alpha = 0.75 + vIntensity * 0.25 + audioIntensity * 0.15;
                        vec3 finalColor = color * (1.0 + vIntensity * 0.6);
                        gl_FragColor = vec4(finalColor, alpha);
                    }
                `,
                transparent: true,
                blending: THREE.AdditiveBlending
            });
            
            const trail = new THREE.LineLoop(trailGeometry, trailMaterial);
            scene.add(trail);

            // Atmosphere
            if (planetType.type !== 'Rocky Desert' && planetType.type !== 'Lava World') {
                const atmGeometry = new THREE.SphereGeometry(size * 1.15, 24, 24);
                const atmMaterial = new THREE.ShaderMaterial({
                    uniforms: {
                        color: { value: new THREE.Color(planetType.colors[0]) }
                    },
                    vertexShader: `
                        varying vec3 vNormal;
                        void main() {
                            vNormal = normalize(normalMatrix * normal);
                            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
                        }
                    `,
                    fragmentShader: `
                        uniform vec3 color;
                        varying vec3 vNormal;
                        void main() {
                            float intensity = pow(0.5 - dot(vNormal, vec3(0.0, 0.0, 1.0)), 2.0);
                            gl_FragColor = vec4(color, intensity * 0.5);
                        }
                    `,
                    transparent: true,
                    blending: THREE.AdditiveBlending,
                    side: THREE.BackSide
                });
                const atmosphere = new THREE.Mesh(atmGeometry, atmMaterial);
                planetMesh.add(atmosphere);
            }

            planets.push({
                mesh: planetMesh,
                planetType: planetType.type,
                size: size,
                orbit: {radius: orbitRadius, speed: orbitSpeed, angle: orbitAngle},
                baseY: 0,
                trail: trail,
                trailMaterial: trailMaterial
            });
        }

        function setupAudio() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();
            analyser = audioContext.createAnalyser();
            analyser.fftSize = 2048;
            analyser.smoothingTimeConstant = 0.85;
            dataArray = new Uint8Array(analyser.frequencyBinCount);
            
            gainNode = audioContext.createGain();
            gainNode.gain.value = 0.5;
            gainNode.connect(audioContext.destination);

            document.getElementById('audioFile').addEventListener('change', async function(e) {
                const file = e.target.files[0];
                if (!file) return;
                
                try {
                    // Resume audio context
                    if (audioContext.state === 'suspended') {
                        await audioContext.resume();
                    }
                    
                    // Stop previous audio
                    if (audioElement) {
                        audioElement.pause();
                        audioElement.src = '';
                        audioElement = null;
                    }
                    if (audioSource) {
                        audioSource.disconnect();
                        audioSource = null;
                    }
                    
                    // Show loading
                    document.getElementById('audioBtn').textContent = 'Loading...';
                    
                    // Create new audio element
                    audioElement = new Audio();
                    const objectURL = URL.createObjectURL(file);
                    audioElement.src = objectURL;
                    audioElement.loop = true;
                    audioElement.preload = 'auto';
                    
                    // Wait for audio to be ready
                    await new Promise((resolve, reject) => {
                        audioElement.addEventListener('canplaythrough', resolve, { once: true });
                        audioElement.addEventListener('error', reject, { once: true });
                        audioElement.load();
                    });
                    
                    // Connect audio
                    audioSource = audioContext.createMediaElementSource(audioElement);
                    audioSource.connect(analyser);
                    analyser.connect(gainNode);
                    
                    // Play
                    await audioElement.play();
                    document.getElementById('audioBtn').textContent = 'Pause';
                    
                } catch (error) {
                    console.error('Audio playback error:', error);
                    document.getElementById('audioBtn').textContent = 'Error - Try Again';
                    alert('Failed to play audio. Please try again.');
                }
            });
        }

        async function initAudio() {
            try {
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
                
                // Hide init button, show other controls
                document.getElementById('initBtn').style.display = 'none';
                document.getElementById('loadFileBtn').style.display = 'inline-block';
                document.getElementById('micBtn').style.display = 'inline-block';
                document.getElementById('ambientBtn').style.display = 'inline-block';
                document.getElementById('audioBtn').style.display = 'inline-block';
                
                // Auto-start ambient
                await generateAmbient();
                
            } catch (error) {
                console.error('Audio init error:', error);
                alert('Failed to initialize audio. Please try again.');
            }
        }

        async function startMicrophone() {
            try {
                // Resume audio context
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
                
                // Stop previous audio
                if (audioElement) {
                    audioElement.pause();
                    audioElement = null;
                }
                if (audioSource) {
                    audioSource.disconnect();
                }
                ambientOscillators.forEach(osc => {
                    if (osc.stop) osc.stop();
                });
                ambientOscillators = [];
                
                const stream = await navigator.mediaDevices.getUserMedia({audio: true});
                audioSource = audioContext.createMediaStreamSource(stream);
                audioSource.connect(analyser);
                analyser.connect(gainNode);
                
                document.getElementById('audioBtn').textContent = 'Stop Mic';
            } catch (error) {
                alert('Microphone not available: ' + error.message);
            }
        }

        async function generateAmbient() {
            try {
                // Resume audio context
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
                
                // Stop previous audio
                if (audioElement) {
                    audioElement.pause();
                    audioElement = null;
                }
                if (audioSource) {
                    audioSource.disconnect();
                    audioSource = null;
                }
                ambientOscillators.forEach(osc => {
                    if (osc.stop) osc.stop();
                });
                ambientOscillators = [];
                
                const filter = audioContext.createBiquadFilter();
                filter.type = 'lowpass';
                filter.frequency.value = 1500;
                filter.Q.value = 0.8;
                
                const reverb = audioContext.createConvolver();
                const reverbTime = 5;
                const sampleRate = audioContext.sampleRate;
                const length = sampleRate * reverbTime;
                const impulse = audioContext.createBuffer(2, length, sampleRate);
                
                for (let channel = 0; channel < 2; channel++) {
                    const channelData = impulse.getChannelData(channel);
                    for (let i = 0; i < length; i++) {
                        channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / length, 3);
                    }
                }
                reverb.buffer = impulse;
                
                const frequencies = [40, 60, 90, 120, 180, 240, 360];
                
                frequencies.forEach((freq, i) => {
                    const osc = audioContext.createOscillator();
                    const oscGain = audioContext.createGain();
                    const lfo = audioContext.createOscillator();
                    const lfoGain = audioContext.createGain();
                    
                    osc.type = ['sine', 'triangle', 'sawtooth'][i % 3];
                    osc.frequency.value = freq;
                    oscGain.gain.value = 0.2 / frequencies.length;
                    
                    lfo.type = 'sine';
                    lfo.frequency.value = 0.03 + Math.random() * 0.12;
                    lfoGain.gain.value = freq * 0.04;
                    
                    lfo.connect(lfoGain);
                    lfoGain.connect(osc.frequency);
                    
                    osc.connect(oscGain);
                    oscGain.connect(filter);
                    
                    lfo.start();
                    osc.start();
                    ambientOscillators.push(osc, lfo);
                    
                    setInterval(() => {
                        if (ambientOscillators.includes(osc)) {
                            const newFreq = freq * (0.9 + Math.random() * 0.2);
                            osc.frequency.exponentialRampToValueAtTime(newFreq, audioContext.currentTime + 8);
                        }
                    }, 8000 + Math.random() * 5000);
                });
                
                filter.connect(reverb);
                reverb.connect(analyser);
                analyser.connect(gainNode);
                
                document.getElementById('audioBtn').textContent = 'Stop Ambient';
            } catch (error) {
                console.error('Ambient generation error:', error);
                alert('Failed to generate ambient audio');
            }
        }

        async function toggleAudio() {
            try {
                if (audioContext.state === 'suspended') {
                    await audioContext.resume();
                }
                
                if (audioElement) {
                    if (audioElement.paused) {
                        await audioElement.play();
                        document.getElementById('audioBtn').textContent = 'Pause';
                    } else {
                        audioElement.pause();
                        document.getElementById('audioBtn').textContent = 'Play';
                    }
                } else if (ambientOscillators.length > 0) {
                    ambientOscillators.forEach(osc => osc.stop());
                    ambientOscillators = [];
                    document.getElementById('audioBtn').textContent = 'Play';
                }
            } catch (error) {
                console.error('Toggle audio error:', error);
            }
        }

        function changeVolume(value) {
            const volume = parseFloat(value) / 100;
            if (gainNode) {
                gainNode.gain.value = volume;
            }
            document.getElementById('volumeDisplay').textContent = value;
        }

        function processAudio() {
            if (!analyser) return;
            
            analyser.getByteFrequencyData(dataArray);

            const bass = getAverageFrequency(0, 250) / 255;
            const mid = getAverageFrequency(250, 2000) / 255;
            const high = getAverageFrequency(2000, 20000) / 255;
            const time = clock.getElapsedTime();

            // Central star
            if (centralStar) {
                const freqValue = (bass * 0.4 + mid * 0.3 + high * 0.3);
                centralStar.material.uniforms.intensity.value = 0.85 + freqValue * 0.5;
                const targetScale = 1 + freqValue * 0.15;
                centralStar.mesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.12);
            }

            // Planets and trails with audio data and rotation
            planets.forEach(planet => {
                // Smooth rotation of planet itself
                planet.mesh.rotation.y += 0.003 * (1 + mid * 0.3);
                
                if (planet.trailMaterial) {
                    // Update audio data array for trail visualization
                    const audioDataArray = new Float32Array(128);
                    for (let i = 0; i < 128; i++) {
                        const dataIndex = Math.floor(i * dataArray.length / 128);
                        audioDataArray[i] = dataArray[dataIndex] / 255.0;
                    }
                    planet.trailMaterial.uniforms.audioData.value = audioDataArray;
                    planet.trailMaterial.uniforms.audioIntensity.value = bass * 0.6 + mid * 0.4;
                    planet.trailMaterial.uniforms.time.value = time;
                    
                }
            });

            // Background stars - much more reactive with audio
            const overallIntensity = (bass + mid + high) / 3;
            backgroundStars.forEach(star => {
                const freqValue = getFrequencyForRange(star.freqRange[0], star.freqRange[1]) / 255;
                
                // When music is playing, stars become much more visible
                const visibilityBoost = overallIntensity > 0.1 ? 1.0 : 0.3;
                
                // Increase opacity range significantly
                const targetOpacity = (star.baseOpacity + freqValue * 0.8) * visibilityBoost;
                star.material.opacity += (targetOpacity - star.material.opacity) * 0.2;
                
                // Make glow more intense
                const targetGlowOpacity = (star.baseGlowOpacity + freqValue * 0.7) * visibilityBoost;
                star.glowMaterial.opacity += (targetGlowOpacity - star.glowMaterial.opacity) * 0.2;
                
                // Scale stars based on audio
                const targetScale = 1 + freqValue * 0.5;
                star.mesh.scale.lerp(new THREE.Vector3(targetScale, targetScale, targetScale), 0.15);
            });

            // Nebulae react to audio
            nebulae.forEach(nebula => {
                if (nebula.material.uniforms) {
                    const nebulaIntensity = (bass * 0.5 + mid * 0.3 + high * 0.2);
                    nebula.material.uniforms.audioIntensity.value = nebulaIntensity;
                }
            });

            drawSpectrum(dataArray);
        }

        function getAverageFrequency(startFreq, endFreq) {
            const nyquist = audioContext.sampleRate / 2;
            const startBin = Math.floor(startFreq / nyquist * dataArray.length);
            const endBin = Math.floor(endFreq / nyquist * dataArray.length);
            
            let sum = 0;
            for (let i = startBin; i < endBin; i++) {
                sum += dataArray[i];
            }
            return sum / (endBin - startBin);
        }

        function getFrequencyForRange(startFreq, endFreq) {
            return getAverageFrequency(startFreq, endFreq);
        }

        function drawSpectrum(dataArray) {
            const canvas = document.getElementById('spectrumCanvas');
            const ctx = canvas.getContext('2d');
            canvas.width = canvas.offsetWidth;
            canvas.height = canvas.offsetHeight;

            const gradient = ctx.createLinearGradient(0, 0, 0, canvas.height);
            gradient.addColorStop(0, 'rgba(100, 200, 255, 0.02)');
            gradient.addColorStop(1, 'rgba(150, 100, 255, 0.02)');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const barWidth = canvas.width / (dataArray.length / 2);
            
            for (let i = 0; i < dataArray.length / 2; i++) {
                const barHeight = (dataArray[i] / 255) * canvas.height * 0.9;
                const hue = 200 + (i / (dataArray.length / 2)) * 60;
                const gradient = ctx.createLinearGradient(0, canvas.height - barHeight, 0, canvas.height);
                gradient.addColorStop(0, `hsla(${hue}, 80%, 65%, 0.95)`);
                gradient.addColorStop(0.5, `hsla(${hue}, 80%, 50%, 0.7)`);
                gradient.addColorStop(1, `hsla(${hue}, 80%, 35%, 0.3)`);
                ctx.fillStyle = gradient;
                
                const x = i * barWidth;
                ctx.beginPath();
                ctx.moveTo(x, canvas.height);
                ctx.lineTo(x, canvas.height - barHeight);
                ctx.lineTo(x + barWidth - 1, canvas.height - barHeight);
                ctx.lineTo(x + barWidth - 1, canvas.height);
                ctx.closePath();
                ctx.fill();
                
                // Glow effect
                if (barHeight > canvas.height * 0.3) {
                    ctx.shadowBlur = 15;
                    ctx.shadowColor = `hsla(${hue}, 80%, 60%, 0.8)`;
                    ctx.fill();
                    ctx.shadowBlur = 0;
                }
            }
        }

        function setupEvents() {
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
            
            const canvas = document.getElementById('canvas');
            canvas.addEventListener('mousedown', e => {
                mouseDown = true;
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            
            canvas.addEventListener('mousemove', e => {
                if (!mouseDown) return;
                
                const deltaX = e.clientX - mouseX;
                const deltaY = e.clientY - mouseY;
                
                cameraRotation.y -= deltaX * 0.004;
                cameraRotation.x -= deltaY * 0.004;
                cameraRotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, cameraRotation.x));
                
                mouseX = e.clientX;
                mouseY = e.clientY;
            });
            
            canvas.addEventListener('mouseup', () => mouseDown = false);
            
            canvas.addEventListener('wheel', e => {
                e.preventDefault();
                const delta = e.deltaY * 0.001;
                cameraVelocity.z += delta * 5;
            });
            
            window.addEventListener('keydown', e => {
                keys[e.key] = true;
                
                // ESC to toggle UI
                if (e.key === 'Escape') {
                    toggleUI();
                }
            });
            window.addEventListener('keyup', e => keys[e.key] = false);
        }

        function seekAudio(value) {
            if (audioElement && audioElement.duration) {
                const seekTime = (value / 100) * audioElement.duration;
                audioElement.currentTime = seekTime;
            }
        }

        function updateAudioTimeline() {
            if (audioElement && audioElement.duration) {
                const currentTime = audioElement.currentTime;
                const duration = audioElement.duration;
                const progress = (currentTime / duration) * 100;
                
                document.getElementById('seekSlider').value = progress;
                document.getElementById('currentTime').textContent = formatTime(currentTime);
                document.getElementById('totalTime').textContent = formatTime(duration);
            }
        }

        function formatTime(seconds) {
            const mins = Math.floor(seconds / 60);
            const secs = Math.floor(seconds % 60);
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        }

        function handleCameraMovement() {
            // Don't move camera if user is typing in an input field
            if (document.activeElement.tagName === 'INPUT' || 
                document.activeElement.tagName === 'SELECT' ||
                document.activeElement.tagName === 'TEXTAREA') {
                return;
            }
            
            // Speed independent of time scale
            const speed = keys['Shift'] ? 4 : 1.8;
            
            // Update camera rotation first
            camera.rotation.order = 'YXZ';
            camera.rotation.y = cameraRotation.y;
            camera.rotation.x = cameraRotation.x;
            
            // Get camera direction vectors from the camera's matrix
            const forward = new THREE.Vector3();
            const right = new THREE.Vector3();
            const up = new THREE.Vector3(0, 1, 0);
            
            camera.getWorldDirection(forward);
            right.crossVectors(forward, up).normalize();
            
            // Apply movement based on pressed keys
            const moveVector = new THREE.Vector3();
            
            if (keys['w'] || keys['W'] || keys['ArrowUp']) {
                moveVector.add(forward.clone().multiplyScalar(speed * 0.4));
            }
            if (keys['s'] || keys['S'] || keys['ArrowDown']) {
                moveVector.add(forward.clone().multiplyScalar(-speed * 0.4));
            }
            if (keys['a'] || keys['A'] || keys['ArrowLeft']) {
                moveVector.add(right.clone().multiplyScalar(-speed * 0.4));
            }
            if (keys['d'] || keys['D'] || keys['ArrowRight']) {
                moveVector.add(right.clone().multiplyScalar(speed * 0.4));
            }
            if (keys['q'] || keys['Q']) {
                moveVector.y += speed * 0.4;
            }
            if (keys['e'] || keys['E']) {
                moveVector.y -= speed * 0.4;
            }

            // Apply smooth acceleration/deceleration
            cameraVelocity.add(moveVector);
            cameraVelocity.multiplyScalar(0.93);
            
            // Update position
            cameraPosition.add(cameraVelocity);
            camera.position.copy(cameraPosition);
        }

        function updateOrbits(delta) {
            const time = clock.getElapsedTime();
            
            planets.forEach(planet => {
                planet.orbit.angle += planet.orbit.speed * delta * timeScale;
                
                // Planet follows the trail path including audio wave displacement
                const trailRadius = planet.orbit.radius;
                const baseX = Math.cos(planet.orbit.angle) * trailRadius;
                const baseZ = Math.sin(planet.orbit.angle) * trailRadius;
                
                // Calculate Y position from audio trail
                const normalizedAngle = (planet.orbit.angle % (Math.PI * 2)) / (Math.PI * 2);
                const audioIndex = Math.floor(normalizedAngle * 127);
                const audioValue = dataArray && dataArray[audioIndex] ? dataArray[audioIndex] / 255 : 0;
                
                // Apply the same wave calculation as in the shader
                let waveY = audioValue * 10.0;
                waveY += Math.sin(normalizedAngle * 30.0 + time * 2.5) * audioValue * 2.0;
                waveY += Math.cos(normalizedAngle * 20.0 - time * 1.8) * audioValue * 1.5;
                
                planet.mesh.position.x = baseX;
                planet.mesh.position.z = baseZ;
                planet.mesh.position.y = waveY;
                
                // Rotate planet
                planet.mesh.rotation.y += 0.01 * (1 + audioValue * 0.5);
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            
            const delta = clock.getDelta();
            const time = clock.getElapsedTime();
            
            if (centralStar) {
                centralStar.material.uniforms.time.value = time;
                centralStar.glowMaterial.uniforms.time.value = time;
            }
            
            // Update nebulae time
            nebulae.forEach(nebula => {
                if (nebula.material.uniforms && nebula.material.uniforms.time) {
                    nebula.material.uniforms.time.value = time;
                }
            });
            
            processAudio();
            handleCameraMovement();
            updateOrbits(delta);
            updateAudioTimeline();
            
            renderer.render(scene, camera);
        }

        function changeTimeSpeed(value) {
            const v = parseFloat(value);
            timeScale = v < 0 ? Math.pow(10, v / 10) : Math.pow(10, v / 10);
            document.getElementById('timeSpeed').textContent = timeScale.toFixed(1);
        }

        function openEditor() {
            document.getElementById('editor').style.display = 'block';
            document.getElementById('overlay').style.display = 'block';
            
            document.getElementById('starTypeSelect').value = centralStar.typeKey;
            document.getElementById('planetCountSlider').value = planets.length;
            updatePlanetCount(planets.length);
        }

        function closeEditor() {
            document.getElementById('editor').style.display = 'none';
            document.getElementById('overlay').style.display = 'none';
        }

        function updatePlanetCount(count) {
            document.getElementById('planetCount').textContent = count;
        }

        function applyChanges() {
            const starTypeKey = document.getElementById('starTypeSelect').value;
            const planetCount = parseInt(document.getElementById('planetCountSlider').value);
            
            // Regenerate with new params
            if (centralStar) {
                scene.remove(centralStar.mesh);
                planets.forEach(p => {
                    scene.remove(p.mesh);
                    if (p.trail) scene.remove(p.trail);
                });
                planets = [];
            }

            createCentralStar(STAR_TYPES[starTypeKey], starTypeKey);
            
            for (let i = 0; i < planetCount; i++) {
                createPlanet(i);
            }

            updateSystemInfo();
            closeEditor();
        }

        function updateSystemInfo() {
            document.getElementById('objectInfo').innerHTML = `
                <div class="stat-line">
                    <span class="stat-label">Star Type:</span>
                    <span class="glow-value">${centralStar.typeKey}</span>
                </div>
                <div class="stat-line">
                    <span class="stat-label">Temperature:</span>
                    <span class="glow-value">${centralStar.type.temp.toLocaleString()} K</span>
                </div>
                <div class="stat-line">
                    <span class="stat-label">Planets:</span>
                    <span class="glow-value">${planets.length}</span>
                </div>
                <br>
                <p style="line-height: 1.8; color: rgba(200, 220, 255, 0.8); font-size: 13px;">
                    ${centralStar.typeKey}-class star with ${planets.length} orbiting planets.
                    Orbital trails react to audio frequencies.
                </p>
            `;
        }

        function saveSystem() {
            const systemData = {
                starType: centralStar.typeKey,
                planets: planets.map(p => ({
                    type: p.planetType,
                    size: p.size,
                    orbitRadius: p.orbit.radius,
                    orbitSpeed: p.orbit.speed
                }))
            };
            
            const dataStr = JSON.stringify(systemData, null, 2);
            const blob = new Blob([dataStr], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.download = `stellar_system_${Date.now()}.json`;
            link.href = url;
            link.click();
        }

        function loadSystem() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = 'application/json';
            input.onchange = e => {
                const file = e.target.files[0];
                const reader = new FileReader();
                reader.onload = event => {
                    try {
                        const systemData = JSON.parse(event.target.result);
                        // Implement loading logic here
                        alert('System loaded!');
                    } catch (err) {
                        alert('Failed to load system');
                    }
                };
                reader.readAsText(file);
            };
            input.click();
        }

        function screenshot() {
            renderer.render(scene, camera);
            const link = document.createElement('a');
            link.download = `stellar_symphony_${Date.now()}.png`;
            link.href = renderer.domElement.toDataURL('image/png');
            link.click();
        }

        uiVisible = false;
        
        function toggleUI() {
            uiVisible = !uiVisible;
            const displayValue = uiVisible ? 'block' : 'none';
            document.querySelectorAll('.ui-panel').forEach(panel => {
                if (panel.id !== 'editor' && panel.id !== 'loading') {
                    panel.style.display = displayValue;
                }
            });
            document.getElementById('info').style.display = 'block';
            document.getElementById('controls').style.display = 'block';
            document.getElementById('audio-controls').style.display = 'block';

        }

        window.addEventListener('load', init);
    </script>
</body>
</html>
